> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.kanxue.com](https://bbs.kanxue.com/thread-275753.htm)

> [原创] UPX 源码学习和简单修改

[原创] UPX 源码学习和简单修改

28 分钟前 37

* * *

之前一直学习如何脱壳，接触到的第一种壳就是 UPX。经过一段脱壳训练后，逐渐对 UPX 的压缩流程有了兴趣。本文是笔者对 UPX 源码的学习记录，包括代码学习过程和源码简单修改，希望对大家有所帮助。

> 分析环境：  
> UPX 版本: 3.96 (https://github.com/upx/upx/releases/download/v3.96/upx-3.96-src.tar.xz)  
> linux 系统: centOS 7 - Linux localhost.localdomain 3.10.0-862.el7.x86_64 #1 SMP Fri Apr 20 16:44:24 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux  
> kali: Linux kali 5.9.0-kali1-amd64 #1 SMP Debian 5.9.1-1kali2 (2020-10-29) x86_64 GNU/Linux  
> 010 Editor 版本: v10.0 (64 bit)

为了方便调试，笔者只分析了 x86-64 位 ELF 文件的加壳流程代码，本文所用程序见结尾文件 `demo`。代码跟踪过程主要参考文章 [UPX 源码分析——加壳篇](https://www.cnblogs.com/ichunqiu/p/7245329.html)，大家有兴趣可详细阅读。这里只介绍大体流程。

#### 加壳流程

UPX 的核心加壳代码是 upx-3.96/src/p_unix.cpp 文件的 pack 函数。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p></td><td><p><code>void PackUnix::pack(OutputFile </code><code>*</code><code>fo)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Filter</code> <code>ft(ph.level);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ft.addvalue </code><code>=</code> <code>0</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>b_len </code><code>=</code> <code>0</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>progid </code><code>=</code> <code>0</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code> <code>set</code> <code>options</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>blocksize </code><code>=</code> <code>opt</code><code>-</code><code>&gt;o_unix.blocksize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(blocksize &lt;</code><code>=</code> <code>0</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>blocksize </code><code>=</code> <code>BLOCKSIZE;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>((off_t)blocksize &gt; file_size)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>blocksize </code><code>=</code> <code>file_size;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code> <code>init compression buffers</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ibuf.alloc(blocksize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>obuf.allocForCompression(blocksize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>fi</code><code>-</code><code>&gt;seek(</code><code>0</code><code>, SEEK_SET);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pack1(fo, ft);&nbsp; </code><code>/</code><code>/</code> <code>generate Elf header, etc.</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>p_info hbuf;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_te32(&amp;hbuf.p_progid, progid);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_te32(&amp;hbuf.p_filesize, file_size);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_te32(&amp;hbuf.p_blocksize, blocksize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>fo</code><code>-</code><code>&gt;write(&amp;hbuf, sizeof(hbuf));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code> <code>append the compressed body</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(pack2(fo, ft)) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code> <code>write block end marker (uncompressed size </code><code>0</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>b_info hdr; memset(&amp;hdr, </code><code>0</code><code>, sizeof(hdr));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>set_le32(&amp;hdr.sz_cpr, UPX_MAGIC_LE32);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>fo</code><code>-</code><code>&gt;write(&amp;hdr, sizeof(hdr));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pack3(fo, ft);&nbsp; </code><code>/</code><code>/</code> <code>append loader</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pack4(fo, ft);&nbsp; </code><code>/</code><code>/</code> <code>append PackHeader </code><code>and</code> <code>overlay_offset; update Elf header</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code> <code>finally</code> <code>check the compression ratio</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(!checkFinalCompressionRatio(fo))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>throwNotCompressible();</code></p><p><code>}</code></p></td></tr></tbody></table>

该函数调用了 4 个关键函数，分别为 pack1、pack2、pack3 和 pack4，代表了加壳的四个步骤。

pack1 函数功能是，写入新文件的 elf 头，写入程序头表，写入 1 个初始化的 l_info 结构。

pack2 函数功能是，对所有类型为 PT_LOAD 的段进行压缩存储。

其中，在对第一个类型为 PT_LOAD 的段 (该块一般包含原文件的文件头和程序头表) 进行压缩时，会将该段分为两个部分分别压缩写入。这两部分为：一、原文件的 elf 头和程序头表；二、该段数据的其他部分。  
例如，demo 文件中第一个 PT_LOAD 段如下

![](https://bbs.kanxue.com/upload/attach/202301/905958_BUM6JGPH9PGVY64.png)

第一段文件偏移为 0，大小为 0x5F0。从图中可以看到文件头 + 程序头表的大小为 0x270，这就是需要压缩的第一块数据。第二块数据就是文件偏移为 0x270，大小为 0x380。

pack3 函数的功能是，写入 loader，压缩原文件中除 PT_LOAD 段之外的其余数据并写入，修正程序头表内容

pack4 函数的功能是，写入 PackHeader 和 overlay_offset。这里 overlay_offset 值为 p_info 字段的文件偏移。本 demo 中为 0xf4。

![](https://bbs.kanxue.com/upload/attach/202301/905958_A5VCSQKKX68483P.png)

#### 文件格式

经过 UPX 处理后，压缩后的文件格式如下。

new eheader(64 bytes) (文件头)  
+ new pheader(56 bytes) * 3 (程序头表)  
+ l_info(12 bytes)  
+ p_info(12 bytes)  
+ b_info(12 bytes) + compressed block (原程序文件头和程序头表)  
+ b_info(12 bytes) + compressed block (第一个类型为 PT_LOAD 的段中除原程序文件头和程序头表的部分)  
+ b_info(12 bytes) + compressed block (第二个类型为 PT_LOAD 的段)  
+ ......  
+ fpad8 (8 字节对齐)  
+ int(4 bytes) (第一个 b_info 的文件偏移)  
+ int(4 bytes) (当前位置的文件偏移，也就是之前所有数据总长度)  
+ loader (加载器，也就是脱壳代码)  
+ b_info(12 bytes) + compressed block (第一个 PT_LOAD 和第二个 PT_LOAD 中间的数据)  
+ b_info(12 bytes) + compressed block (第二个 PT_LOAD 和第三个 PT_LOAD 中间的数据)  
+ ......  
+ b_info(12 bytes) + compressed block (最后一个 PT_LOAD 到文件末尾之间的数据)  
+ 00 00 00 00 55 50 58 21 00 00 00 00 (b_info)  
+ fpad4 (4 字节对齐)  
+ PackHeader(32 bytes)  
+ int(4 bytes) (p_info 的文件偏移)

其中，b_info、l_info 和 p_info 是三个结构体。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></td><td><p><code>/</code><code>/</code> <code>在每个压缩块之前，存放压缩前和压缩后的数据大小</code></p><p><code>struct b_info {&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>12</code><code>-</code><code>byte header before each compressed block</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t sz_unc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>uncompressed_size</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t sz_cpr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>compressed_size</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_method;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>compression algorithm</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_ftid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>filter</code> <code>id</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_cto8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>filter</code> <code>parameter</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_unused;</code></p><p><code>};</code></p><p><code>/</code><code>/</code> <code>存放校验数据和</code><code>"UPX!"</code><code>魔数</code></p><p><code>struct l_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>12</code><code>-</code><code>byte trailer </code><code>in</code> <code>header </code><code>for</code> <code>loader (offset </code><code>116</code><code>)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t l_checksum;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t l_magic;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint16_t l_lsize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint8_t&nbsp; l_version;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint8_t&nbsp; l_format;</code></p><p><code>};</code></p><p><code>/</code><code>/</code> <code>全文只有一个该结构体，存储的是原文件的大小</code></p><p><code>struct p_info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>12</code><code>-</code><code>byte packed program header follows stub loader</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t p_progid;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t p_filesize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t p_blocksize;&nbsp;&nbsp;</code></p><p><code>};</code></p></td></tr></tbody></table>

#### loader

针对 demo 文件的 loader 生成代码在 upx-3.96/src/p_lx_elf.cpp 文件的 PackLinuxElf64::buildLinuxLoader() 函数中，loader 中各 section 的相应顺序由函数 PackLinuxElf::addStubEntrySections() 确定。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p></td><td><p><code>void</code></p><p><code>PackLinuxElf::addStubEntrySections(</code><code>Filter</code> <code>const </code><code>*</code><code>)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAINX"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(hasLoaderSection(</code><code>"ELFMAINXu"</code><code>)) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code> <code>brk() trouble </code><code>if</code> <code>static</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAINXu"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>/</code><code>/</code><code>addLoader(getDecompressorSections(), NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>( M_IS_NRV2E(ph.method) ? </code><code>"NRV_HEAD,NRV2E,NRV_TAIL"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: M_IS_NRV2D(ph.method) ? </code><code>"NRV_HEAD,NRV2D,NRV_TAIL"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: M_IS_NRV2B(ph.method) ? </code><code>"NRV_HEAD,NRV2B,NRV_TAIL"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: M_IS_LZMA(ph.method)&nbsp; ? </code><code>"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: NULL), NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(hasLoaderSection(</code><code>"CFLUSH"</code><code>))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"CFLUSH"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAINY,IDENTSTR"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(hasLoaderSection(</code><code>"ELFMAINZe"</code><code>)) { </code><code>/</code><code>/</code> <code>ppc64 big</code><code>-</code><code>endian only</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAINZe"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"+40,ELFMAINZ"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(hasLoaderSection(</code><code>"ANDMAJNZ"</code><code>)) { </code><code>/</code><code>/</code> <code>Android trouble with args to DT_INIT</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(opt</code><code>-</code><code>&gt;o_unix.android_shlib) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ANDMAJNZ"</code><code>, NULL);&nbsp; </code><code>/</code><code>/</code> <code>constant PAGE_SIZE</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAJNZ"</code><code>, NULL);&nbsp; </code><code>/</code><code>/</code> <code>PAGE_SIZE </code><code>from</code> <code>AT_PAGESZ</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAKNZ"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(hasLoaderSection(</code><code>"ELFMAINZu"</code><code>)) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"ELFMAINZu"</code><code>, NULL);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addLoader(</code><code>"FOLDEXEC"</code><code>, NULL);</code></p><p><code>}</code></p></td></tr></tbody></table>

除了 "FOLDEXEC"，其余 section 的汇编代码在 upx-3.96/src/stub/src/amd64-linux.elf-entry.S 文件中，编译后的二进制数据在文件 upx-3.96/src/stub/amd64-linux.elf-entry.h 中。loader 直接使用 *.h 文件中的二进制数据。

最终，demo 文件压缩后 loader 的结构如下

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><p><code>ELFMAINX</code></p><p><code>NRV_HEAD</code></p><p><code>NRV2E&nbsp;&nbsp;&nbsp;</code></p><p><code>NRV_TAIL</code></p><p><code>ELFMAINY</code></p><p><code>IDENTSTR</code></p><p><code>+</code><code>40</code> <code>(</code><code>4</code><code>字节对齐)</code></p><p><code>ELFMAINZ</code></p><p><code>FOLDEXEC</code></p></td></tr></tbody></table>

#### FOLDEXEC

FOLDEXEC 节存放的是压缩后的数据，源数据是编译后的二进制数据，存放在 upx-3.96/src/stub/amd64-linux.elf-fold.h 文件中。  
编译前的代码分为两部分，一部分是 upx-3.96/src/stub/src/amd64-linux.elf-fold.S 文件中的汇编代码，一部分是 upx-3.96/src/stub/src/amd64-linux.elf-main.c 文件中的 C 代码。该文件核心是 upx_main()函数，此函数返回值为解压后程序 (原程序) 的入口点.

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p></td><td><p><code>/</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code></p><p><code>/</code><code>/</code> <code>upx_main </code><code>-</code> <code>called by our entry code</code></p><p><code>/</code><code>/</code></p><p><code>/</code><code>/</code> <code>This function </code><code>is</code> <code>optimized </code><code>for</code> <code>size.</code></p><p><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>/</code></p><p><code>void </code><code>*</code></p><p><code>upx_main(&nbsp; </code><code>/</code><code>/</code> <code>returns entry address</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>struct b_info const </code><code>*</code><code>const bi,&nbsp; </code><code>/</code><code>/</code> <code>1st</code> <code>block header</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>size_t const sz_compressed,&nbsp; </code><code>/</code><code>/</code> <code>total length</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Elf64_Ehdr </code><code>*</code><code>const ehdr,&nbsp; </code><code>/</code><code>/</code> <code>temp char[sz_ehdr] </code><code>for</code> <code>decompressing</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Elf64_auxv_t </code><code>*</code><code>const av,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f_expand </code><code>*</code><code>const f_exp,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f_unfilter </code><code>*</code><code>const f_unf</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>, Elf64_Addr elfaddr&nbsp; </code><code>/</code><code>/</code> <code>In: &amp;Elf64_Ehdr </code><code>for</code> <code>stub</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>, Elf64_Addr </code><code>*</code><code>p_reloc&nbsp; </code><code>/</code><code>/</code> <code>In: &amp;Elf64_Ehdr </code><code>for</code> <code>stub; Out: </code><code>'slide'</code> <code>for</code> <code>PT_INTERP</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>, size_t const PAGE_MASK</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>, Elf64_Addr elfaddr</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>, size_t const PAGE_MASK</code></p><p><code>)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>......</code></p><p><code>}</code></p></td></tr></tbody></table>

在阅读 UPX 源码过程中，经常需要对压缩后的文件格式进行分析，以验证自己的猜想。因为笔者经常使用 010 作为二进制分析工具，遂决定自己写一个 010 模板。这里是对标准的 ELF.bt(V2.5.5) 进行了修改。

首先，将上节所述的三个关键结构体加入到模板中，为了增加可读性，在个别字段添加属性值。添加的结构体代码如下：

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p></td><td><p><code>typedef uint uint32_t;</code></p><p><code>typedef ushort uint16_t;</code></p><p><code>typedef uchar uint8_t;</code></p><p><code>struct b_info&nbsp; </code><code>/</code><code>/</code> <code>12</code><code>-</code><code>byte header before each compressed block</code></p><p><code>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t sz_unc&lt;</code><code>format</code> <code>=</code> <code>hex</code><code>, comment </code><code>=</code> <code>"Uncompressed size"</code><code>&gt;; </code><code>/</code><code>/</code> <code>uncompressed_size</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t sz_cpr&lt;</code><code>format</code> <code>=</code> <code>hex</code><code>, comment </code><code>=</code> <code>"Compressed size"</code><code>&gt;;&nbsp;&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>compressed_size</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_method&lt;comment </code><code>=</code> <code>"Compression algorithm"</code><code>&gt;; </code><code>/</code><code>/</code> <code>compression algorithm</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_ftid;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>filter</code> <code>id</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_cto8;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>filter</code> <code>parameter</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>unsigned char b_unused;</code></p><p><code>};</code></p><p><code>struct l_info </code><code>/</code><code>/</code> <code>12</code><code>-</code><code>byte trailer </code><code>in</code> <code>header </code><code>for</code> <code>loader (offset </code><code>116</code><code>)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t l_checksum;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t l_magic&lt;</code><code>format</code> <code>=</code> <code>hex</code><code>, comment </code><code>=</code> <code>"UPX!"</code><code>&gt;;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint16_t l_lsize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint8_t l_version;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint8_t l_format;</code></p><p><code>};</code></p><p><code>struct p_info </code><code>/</code><code>/</code> <code>12</code><code>-</code><code>byte packed program header follows stub loader</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t p_progid;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t p_filesize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32_t p_blocksize;</code></p><p><code>};</code></p><p><code>typedef struct</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>b_info bheader;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>char data[bheader.sz_cpr];</code></p><p><code>}cblock;</code></p><p><code>typedef struct</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32 offset_b_info;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>uint32 data_size;</code></p><p><code>}endheader;</code></p></td></tr></tbody></table>

然后，将原来模板中 file 结构体中对 section 的解析代码去掉，因为 UPX 压缩后的文件没有相关字段。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p></td><td><p><code>/</code><code>/</code> <code>需要删除的代码</code></p><p><code>/</code><code>/</code> <code>Find the header name location </code><code>869</code><code>行</code></p><p><code>local quad section_name_off </code><code>=</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>file</code><code>.elf_header.e_shoff_SECTION_HEADER_OFFSET_IN_FILE </code><code>+</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>(</code><code>file</code><code>.elf_header.e_shentsize_SECTION_HEADER_ENTRY_SIZE </code><code>*</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>file</code><code>.elf_header.e_shtrndx_STRING_TABLE_INDEX);</code></p><p><code>/</code><code>/</code> <code>Find the header name block</code></p><p><code>if</code> <code>(</code><code>file</code><code>.elf_header.e_ident.ei_class_2 </code><code>=</code><code>=</code> <code>ELFCLASS32) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>......</code></p><p><code>} </code><code>else</code> <code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>......</code></p><p><code>}</code></p><p><code>local </code><code>int</code> <code>sec_tbl_cur_elem;</code></p><p><code>/</code><code>/</code> <code>Find the section headers</code></p><p><code>if</code><code>(</code><code>file</code><code>.elf_header.e_shnum_NUMBER_OF_SECTION_HEADER_ENTRIES &gt; </code><code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>......</code></p><p><code>}</code></p><p><code>local </code><code>int</code> <code>sym_sect;</code></p><p><code>local </code><code>int</code> <code>sym_name_sect;</code></p><p><code>/</code><code>/</code> <code>Find the symbol section</code></p><p><code>sym_sect </code><code>=</code> <code>FindNamedSection(</code><code>".symtab"</code><code>);</code></p><p><code>if</code><code>(sym_sect &gt;</code><code>=</code> <code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>......</code></p><p><code>}</code></p><p><code>/</code><code>/</code> <code>Find the dynamic symbol section</code></p><p><code>sym_sect </code><code>=</code> <code>FindNamedSection(</code><code>".dynsym"</code><code>);</code></p><p><code>if</code><code>(sym_sect &gt;</code><code>=</code> <code>0</code><code>) {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>......</code></p><p><code>}</code></p></td></tr></tbody></table>

最后，在 file 结构体中 program_header_table 结构体生成之后，添加 l_info 结构之后的数据解析代码。

<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p></td><td><p><code>/</code><code>/</code> <code>需要添加的代码&nbsp; </code><code>869</code><code>行</code></p><p><code>FSeek(</code><code>file</code><code>.elf_header.e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE </code><code>+</code> <code>file</code><code>.elf_header.e_phentsize_PROGRAM_HEADER_ENTRY_SIZE_IN_FILE </code><code>*</code> <code>file</code><code>.elf_header.e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES);</code></p><p><code>l_info linfone;</code></p><p><code>p_info pinfone&lt;comment </code><code>=</code> <code>"Original file size"</code><code>&gt;;</code></p><p><code>/</code><code>/</code> <code>Compressed block of PT_LOAD</code></p><p><code>local uint64 now_offsize;</code></p><p><code>now_offsize </code><code>=</code> <code>file</code><code>.elf_header.e_phoff_PROGRAM_HEADER_OFFSET_IN_FILE </code><code>+</code> <code>file</code><code>.elf_header.e_phentsize_PROGRAM_HEADER_ENTRY_SIZE_IN_FILE </code><code>*</code> <code>file</code><code>.elf_header.e_phnum_NUMBER_OF_PROGRAM_HEADER_ENTRIES </code><code>+</code> <code>24</code><code>;</code></p><p><code>local uint64 tmp_offsize </code><code>=</code> <code>0</code><code>;</code></p><p><code>local uint64 tmp </code><code>=</code> <code>0</code><code>;</code></p><p><code>struct</code></p><p><code>{&nbsp;&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(true)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tmp_offsize </code><code>=</code> <code>now_offsize </code><code>+</code> <code>(</code><code>7u</code> <code>&amp; (</code><code>0</code> <code>-</code> <code>now_offsize));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tmp </code><code>=</code> <code>ReadInt64(tmp_offsize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(((tmp&amp;</code><code>0xffffffff</code><code>) </code><code>=</code><code>=</code> <code>0x100</code><code>) &amp;&amp; (((tmp&gt;&gt;</code><code>32</code><code>)&amp;</code><code>0xffffffff</code><code>) </code><code>=</code><code>=</code> <code>(tmp_offsize </code><code>+</code> <code>4</code><code>)))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>break</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>FSeek(now_offsize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cblock a;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>now_offsize </code><code>=</code> <code>now_offsize </code><code>+</code> <code>a.bheader.sz_cpr </code><code>+</code> <code>12</code> <code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>} cpr_load&lt;comment </code><code>=</code> <code>"Compressed block of PT_LOAD"</code><code>&gt;;</code></p><p><code>FSeek(tmp_offsize);</code></p><p><code>endheader headerEND;</code></p><p><code>local uint64 sizeloader </code><code>=</code> <code>program_header_table.program_table_element[</code><code>0</code><code>].p_filesz_SEGMENT_FILE_LENGTH </code><code>-</code> <code>tmp_offsize </code><code>-</code> <code>8</code><code>;</code></p><p><code>uchar loader[sizeloader];</code></p><p><code>/</code><code>/</code> <code>Compressed block of GAPS</code></p><p><code>FSeek(program_header_table.program_table_element[</code><code>0</code><code>].p_filesz_SEGMENT_FILE_LENGTH);</code></p><p><code>now_offsize </code><code>=</code> <code>program_header_table.program_table_element[</code><code>0</code><code>].p_filesz_SEGMENT_FILE_LENGTH;</code></p><p><code>tmp_offsize </code><code>=</code> <code>0</code><code>;</code></p><p><code>tmp </code><code>=</code> <code>0</code><code>;</code></p><p><code>struct</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(true)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tmp_offsize </code><code>=</code> <code>now_offsize;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tmp </code><code>=</code> <code>ReadInt64(tmp_offsize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(((tmp &amp; </code><code>0xffffffff</code><code>) </code><code>=</code><code>=</code> <code>0</code><code>) &amp;&amp; (((tmp &gt;&gt; </code><code>32</code><code>) &amp; </code><code>0xffffffff</code><code>) </code><code>=</code><code>=</code> <code>(</code><code>0x21585055</code><code>)))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>break</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>FSeek(now_offsize);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cblock b;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>now_offsize </code><code>=</code> <code>now_offsize </code><code>+</code> <code>b.bheader.sz_cpr </code><code>+</code> <code>12</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>} cpr_gaps&lt;comment </code><code>=</code> <code>"Compressed block of GAPS"</code><code>&gt;;</code></p><p><code>b_info check_upx&lt;comment </code><code>=</code> <code>"Block end marker (uncompressed size 0, compressed size 559435861)"</code><code>&gt;;</code></p><p><code>tmp_offsize </code><code>=</code> <code>tmp_offsize </code><code>+</code> <code>12</code><code>;</code></p><p><code>tmp_offsize </code><code>=</code> <code>tmp_offsize </code><code>+</code> <code>(</code><code>3u</code> <code>&amp; (</code><code>0</code> <code>-</code> <code>tmp_offsize));</code></p><p><code>FSeek(tmp_offsize);</code></p><p><code>uchar PackHeader[</code><code>32</code><code>]&lt;comment </code><code>=</code> <code>"PackHeader"</code><code>&gt;;</code></p><p><code>uint32 size_p_info&lt;</code><code>format</code> <code>=</code> <code>hex</code><code>, comment </code><code>=</code> <code>"Offset of p_info"</code><code>&gt;;</code></p></td></tr></tbody></table>

最终效果如下，红框中是我们添加的新结构。

![](https://bbs.kanxue.com/upload/attach/202301/905958_YVVM5AQ3TW6BWNN.png)

修改完成的模板见结尾文件 `upx.bt`。因为文件格式问题，该模板只适用于 demo 文件压缩后的文件。大家有其他需求可以在此基础上自己修改。

之前做病毒分析时，碰到了一个无法使用标准 UPX 程序解压的程序。后来通过搜寻资料和学习，了解到有多种方式可实现该效果。基本思路是修改替换程序中的特征字符，常见的修改方法如下：

1.  UPX 两个区段名称修改
2.  PE 中 DOS 头修改
3.  三个 UPX 特征码修改（参考 EXEINFO 等壳识别工具中的特征匹配规则）
4.  UPX 相关字符串去除或修改

据此，笔者萌生直接对源码进行修改的想法，所以有以下两个简单尝试。

1.  入口点字段修改
2.  压缩数据修改

#### 入口点字段修改

本次尝试主要是修改源程序的入口点位置，使常规的 UPX 解压程序后无法快速找到正确的入口点位置。

##### 代码修改

1.  存储入口点之前，处理该值，这里异或一个常量 0xdeafdeaf。文件 upx-3.96/src/p_unix.cpp 添加如下代码
    
    <table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p></td><td><p><code>334</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>int</code> <code>l </code><code>=</code> <code>fi</code><code>-</code><code>&gt;readx(hdr_ibuf, hdr_u_len);</code></p><p><code>335</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>/</code></p><p><code>336</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code> <code>add </code><code>2022</code><code>-</code><code>11</code><code>-</code><code>29</code> <code>20</code><code>:</code><code>02</code></p><p><code>337</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code> <code>edit </code><code>2022</code><code>-</code><code>12</code><code>-</code><code>12</code> <code>10</code><code>:</code><code>19</code></p><p><code>338</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char </code><code>*</code> <code>ttt </code><code>=</code> <code>(unsigned char </code><code>*</code><code>)hdr_ibuf;</code></p><p><code>339</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Elf64_Ehdr </code><code>*</code><code>tmp </code><code>=</code> <code>(Elf64_Ehdr </code><code>*</code><code>)ttt;</code></p><p><code>340</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>tmp</code><code>-</code><code>&gt;e_entry </code><code>=</code> <code>(tmp</code><code>-</code><code>&gt;e_entry ^ </code><code>0xdeafdeaf</code><code>);</code></p><p><code>341</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>*</code><code>/</code></p></td></tr></tbody></table>
2.  解压得到入口点之后，处理该值，也是异或常量 0xdeafdeaf。这里有两种方式，实现的功能一样。
    

*   文件 upx-3.96/src/stub/src/amd64-linux.elf-fold.S 添加汇编代码`xor $3736067759,%eax`<table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>movq </code><code>%</code><code>rbp,</code><code>%</code><code>arg5&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>call upx_main&nbsp;</code></p><p><code>/</code><code>*</code> <code>entry</code><code>=</code> <code>upx_main(b_info </code><code>*</code><code>arg1, total_size arg2, Elf64_Ehdr </code><code>*</code><code>arg3,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Elf32_Auxv_t </code><code>*</code><code>arg4, f_decompr arg5, f_unf arg6,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Elf64_Addr elfaddr )</code></p><p><code>*</code><code>/</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>xor $</code><code>3736067759</code><code>,</code><code>%</code><code>eax&nbsp;&nbsp;&nbsp; </code><code>/</code><code>/</code> <code>add </code><code>2022</code><code>-</code><code>12</code><code>-</code><code>12</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>addq $</code><code>1</code><code>*</code><code>NBPW</code><code>+</code><code>OVERHEAD,</code><code>%</code><code>rsp&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>movq </code><code>%</code><code>rax,</code><code>4</code><code>*</code><code>NBPW(</code><code>%</code><code>rsp)&nbsp;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pop </code><code>%</code><code>rbx&nbsp;</code></p></td></tr></tbody></table>
*   文件 upx-3.96/src/stub/amd64-linux.elf-fold.h 修改二进制数据，修改三处代码<table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><p><code>unsigned char stub_amd64_linux_elf_fold[</code><code>2251</code><code>] </code><code>=</code> <code>{</code></p><p><code>-</code><code>&gt;</code></p><p><code>unsigned char stub_amd64_linux_elf_fold[</code><code>2256</code><code>] </code><code>=</code> <code>{</code></p></td></tr></tbody></table><table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><p><code>/</code><code>*</code> <code>0x01d0</code> <code>*</code><code>/</code> <code>137</code><code>,</code><code>232</code><code>,</code><code>232</code><code>,</code><code>172</code><code>,&nbsp; </code><code>5</code><code>,&nbsp; </code><code>0</code><code>,&nbsp; </code><code>0</code><code>, </code><code>72</code><code>,</code><code>129</code><code>,</code><code>196</code><code>,&nbsp; </code><code>8</code><code>,&nbsp; </code><code>8</code><code>,&nbsp; </code><code>0</code><code>,&nbsp; </code><code>0</code><code>, </code><code>72</code><code>,</code><code>137</code><code>,</code></p><p><code>-</code><code>&gt;</code></p><p><code>/</code><code>*</code> <code>0x01d0</code> <code>*</code><code>/</code> <code>137</code><code>,</code><code>232</code><code>,</code><code>232</code><code>,</code><code>177</code><code>,&nbsp; </code><code>5</code><code>,&nbsp; </code><code>0</code><code>,&nbsp; </code><code>0</code><code>, </code><code>53</code><code>,</code><code>175</code><code>,</code><code>222</code><code>,</code><code>175</code><code>,</code><code>222</code><code>, </code><code>72</code><code>,</code><code>129</code><code>,</code><code>196</code><code>,&nbsp; </code><code>8</code><code>,&nbsp; </code><code>8</code><code>,&nbsp; </code><code>0</code><code>,&nbsp; </code><code>0</code><code>, </code><code>72</code><code>,</code><code>137</code><code>,</code></p></td></tr></tbody></table>
    
    > xor eax, 3736067759 -> 35 AF DE AF DE -> 53,175,222,175,222
    

##### 验证

1.  使用修改源码后的程序加壳，程序可正常执行。这里的 UPX 版本是 3.96  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_DN9USZZH3HY93HA.png)
2.  在 kali 上执行加壳后的程序，可正常执行  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_P9E9BG9S6N4WAYJ.png)
3.  使用 kali 上的 UPX 程序解压缩该程序（UPX 版本为 3.96）, 执行程序提示段错误  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_KWDEXV388VYG9NC.png)

#### 压缩数据修改

上面对于入口点的修改虽然成功了，但是压缩后的程序仍然可被解压。而且从原理来看，解压后是可以看到原程序代码执行逻辑的。所以笔者有了第二次代码修改。主要修改思路是，对压缩之前的数据进行处理，然后再进行压缩。这样标准 UPX 就无法解压我们自己压缩的程序，比只对入口点的修改效果更好。

##### 代码修改

1.  压缩前修改数据，我们做一个简单的异或处理，这里对所有的数据异或 0xe9(十进制为 233)  
    文件：upx-3.96/src/compress.cpp  
    upx_compress 函数修改，核心部分
    
    <table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></td><td><p><code>96</code>&nbsp;</p><p><code>97</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code> <code>debug</code></p><p><code>98</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>cresult</code><code>-</code><code>&gt;method </code><code>=</code> <code>method;</code></p><p><code>99</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>cresult</code><code>-</code><code>&gt;level </code><code>=</code> <code>level;</code></p><p><code>100</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>cresult</code><code>-</code><code>&gt;u_len </code><code>=</code> <code>src_len;</code></p><p><code>101</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>cresult</code><code>-</code><code>&gt;c_len </code><code>=</code> <code>0</code><code>;</code></p><p><code>102</code></p><p><code>103</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p><p><code>104</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>const unsigned char </code><code>*</code><code>tmp </code><code>=</code> <code>(const unsigned char </code><code>*</code><code>)src;</code></p><p><code>105</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char </code><code>*</code> <code>tmp0 </code><code>=</code> <code>(unsigned char</code><code>*</code><code>)malloc(src_len</code><code>*</code><code>sizeof(char));</code></p><p><code>106</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char </code><code>*</code> <code>tmp1 </code><code>=</code> <code>tmp0;</code></p><p><code>107</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>memcpy(tmp0, tmp, src_len);</code></p><p><code>108</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>size_t i </code><code>=</code> <code>0</code><code>;</code></p><p><code>109</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>for</code><code>(i </code><code>=</code><code>0</code><code>;i&lt;src_len;i</code><code>+</code><code>+</code><code>)</code></p><p><code>110</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>{</code></p><p><code>111</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>(</code><code>*</code><code>tmp0)</code><code>=</code><code>(</code><code>*</code><code>tmp0)^</code><code>0xe9</code><code>;</code></p><p><code>112</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>tmp0 </code><code>=</code> <code>tmp0 </code><code>+</code> <code>1</code><code>;</code></p><p><code>113</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>}</code></p><p><code>114</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>src</code><code>=</code><code>tmp1;</code></p><p><code>115</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p></td></tr></tbody></table>
    
    upx_decompress 函数修改，此处修改主要是因为在文件 upx-3.96/src/packer.cpp 的 Packer::compress 函数中，会对压缩后的数据进行解压验证，需要保持压缩和解压函数逻辑对称。
    
    <table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><p><code>190</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>else</code> <code>{</code></p><p><code>191</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>throwInternalError(</code><code>"unknown decompression method"</code><code>);</code></p><p><code>192</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>}</code></p><p><code>193</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p><p><code>194</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char</code><code>*</code> <code>dst_tmp</code><code>=</code><code>dst;</code></p><p><code>195</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>size_t i </code><code>=</code> <code>0</code><code>;</code></p><p><code>196</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>for</code><code>(i </code><code>=</code><code>0</code><code>;i&lt;(</code><code>*</code><code>dst_len);i</code><code>+</code><code>+</code><code>)</code></p><p><code>197</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>{</code></p><p><code>198</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>(</code><code>*</code><code>dst)</code><code>=</code><code>(</code><code>*</code><code>dst)^</code><code>0xe9</code><code>;</code></p><p><code>199</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>dst </code><code>=</code> <code>dst</code><code>+</code> <code>1</code><code>;</code></p><p><code>200</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>}</code></p><p><code>201</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>dst </code><code>=</code> <code>dst_tmp;</code></p><p><code>202</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p></td></tr></tbody></table>
2.  upx 在加载 loader 是会对其进行压缩处理，而解压算法已写成汇编代码，修改起来比较麻烦。这里我就对 loader 数据多进行一次处理，以抵消 upx-3.96/src/compress.cpp 文件 upx_compress 函数中添加的异或处理。  
    文件：upx-3.96/src/p_lx_elf.cpp
    
    <table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><p><code>1222</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned h_sz_cpr </code><code>=</code> <code>h.sz_cpr;</code></p><p><code>1223</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p><p><code>1224</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code> <code>add </code><code>2022</code><code>-</code><code>12</code><code>-</code><code>29</code> <code>13</code><code>:</code><code>58</code></p><p><code>1225</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char </code><code>*</code> <code>tmp </code><code>=</code> <code>(unsigned char</code><code>*</code><code>)malloc(h.sz_unc</code><code>*</code><code>sizeof(char));</code></p><p><code>1226</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>memcpy(tmp,uncLoader,h.sz_unc);</code></p><p><code>1227</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char </code><code>*</code> <code>tmp0 </code><code>=</code> <code>tmp;</code></p><p><code>1228</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>size_t i </code><code>=</code> <code>0</code><code>;</code></p><p><code>1229</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>for</code><code>(i</code><code>=</code><code>0</code><code>;i&lt;h.sz_unc;i</code><code>+</code><code>+</code><code>)</code></p><p><code>1230</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>{</code></p><p><code>1231</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>(</code><code>*</code><code>tmp)</code><code>=</code><code>(</code><code>*</code><code>tmp)^</code><code>0xe9</code><code>;</code></p><p><code>1232</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>tmp</code><code>=</code><code>tmp</code><code>+</code><code>1</code><code>;</code></p><p><code>1233</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>}</code></p><p><code>1234</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p><p><code>1235</code>&nbsp;&nbsp;&nbsp;&nbsp; <code>int</code> <code>r </code><code>=</code> <code>upx_compress(tmp0, h.sz_unc, sizeof(h) </code><code>+</code> <code>cprLoader, &amp;h_sz_cpr,</code></p><p><code>1236</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>NULL, ph.method, </code><code>10</code><code>, NULL, NULL); </code><code>/</code><code>/</code> <code>edit uncLoader </code><code>-</code><code>&gt; tmp0</code></p></td></tr></tbody></table>
3.  因为原数据压缩前进行了处理，为保证执行时程序逻辑不变，需要对解压后的数据进行逆处理。下面就是对 loader 的源码进行修改。  
    文件：upx-3.96/src/stub/src/amd64-linux.elf-main.c
    
    <table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></td><td><p><code>194</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>int</code> <code>const j </code><code>=</code> <code>(</code><code>*</code><code>f_exp)((unsigned char </code><code>*</code><code>)xi</code><code>-</code><code>&gt;buf, h.sz_cpr,</code></p><p><code>195</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>(unsigned char </code><code>*</code><code>)xo</code><code>-</code><code>&gt;buf, &amp;out_len,</code></p><p><code>196</code></p><p><code>197</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>*</code><code>(</code><code>int</code> <code>*</code><code>)(void </code><code>*</code><code>)&amp;h.b_method</code></p><p><code>198</code></p><p><code>199</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>h.b_method</code></p><p><code>200</code></p><p><code>201</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>);</code></p><p><code>202</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p><p><code>203</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>unsigned char </code><code>*</code><code>tmp</code><code>=</code><code>(unsigned char</code><code>*</code><code>)xo</code><code>-</code><code>&gt;buf;</code></p><p><code>204</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>size_t i </code><code>=</code> <code>0</code><code>;</code></p><p><code>205</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>for</code><code>(i </code><code>=</code> <code>0</code><code>; i &lt; h.sz_unc; i</code><code>+</code><code>+</code><code>)</code></p><p><code>206</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>{</code></p><p><code>207</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>*</code><code>tmp</code><code>=</code><code>(</code><code>*</code><code>tmp)^</code><code>0xe9</code><code>;</code></p><p><code>208</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>tmp </code><code>=</code> <code>tmp </code><code>+</code> <code>1</code><code>;</code></p><p><code>209</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>}</code></p><p><code>210</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code><code>/</code></p></td></tr></tbody></table>

##### 验证

1.  编译后的程序版本为 3.96  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_TUZUXUYDWPQJ9WK.png)  
    对 demo 文件进行压缩处理，可以看到处理后的文件大小，文件也可以正常执行  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_D2WZ5D2Y5AV7UVR.png)
2.  将该文件拷贝到 kali 中，也可以正常执行  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_Q7848888EXX3HDV.png)
3.  使用 kali 自带的 UPX，版本 3.96 对压缩后的文件进行解压，提示解压失败。  
    ![](https://bbs.kanxue.com/upload/attach/202301/905958_JHTFKYJ7NBYDBAN.png)

本文主要介绍了三个部分的内容：

1.  UPX 源码简单介绍，包括加壳的流程和加壳后的文件格式。
2.  根据第一部分介绍的文件格式，对标准 ELF.bt 文件进行修改，使其可以解析加壳后的文件。
3.  介绍两种 UPX 源码简单修改方式：一是修改文件入口点，二是修改加壳的数据。

文章较短，如有不足，恳请指正，不胜感激。

> https://www.cnblogs.com/ichunqiu/p/7245329.html  
> https://bbs.kanxue.com/thread-257797.htmtmnxue.com/thread-257797.htm

[看雪招聘平台创建简历并且简历完整度达到 90% 及以上可获得 500 看雪币～](https://job.kanxue.com/position-list.htm)